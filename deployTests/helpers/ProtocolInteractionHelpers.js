// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var LetOps = require("../../test/library/LetOps.js");
var Globals = require("../../test/library/Globals.js");
var Helpers = require("../../test/library/Helpers.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var SyntheticToken = require("../../test/library/contracts/SyntheticToken.js");
var OracleManagerMock = require("../../test/library/contracts/OracleManagerMock.js");

var minSenderBalance = Globals.bnFromString("50000000000000000");

var minRecieverBalance = Globals.bnFromString("20000000000000000");

function topupBalanceIfLow(from, to_) {
  return LetOps.AwaitThen.let_(from.getBalance(), (function (senderBalance) {
                if (Globals.bnLt(senderBalance, minSenderBalance)) {
                  Js_exn.raiseError("WARNING - Sender doesn't have enough eth - need at least 0.05 ETH! (top up to over 1 ETH to be safe)");
                }
                return LetOps.Await.let_(to_.getBalance(), (function (recieverBalance) {
                              if (Globals.bnLt(recieverBalance, minRecieverBalance)) {
                                from.sendTransaction({
                                      to_: to_.address,
                                      value: minRecieverBalance
                                    });
                                return ;
                              }
                              
                            }));
              }));
}

function setOracleManagerPrice(longShort, marketIndex, admin) {
  return LetOps.AwaitThen.let_(longShort.oracleManagers(marketIndex), (function (oracleManagerAddr) {
                return LetOps.AwaitThen.let_(OracleManagerMock.at(oracleManagerAddr), (function (oracleManager) {
                              return LetOps.AwaitThen.let_(oracleManager.getLatestPrice(), (function (currentPrice) {
                                            var nextPrice = Globals.div(Globals.mul(currentPrice, Globals.bnFromInt(101)), Globals.bnFromInt(100));
                                            return oracleManager.connect(admin).setPrice(nextPrice);
                                          }));
                            }));
              }));
}

function updateSystemState(longShort, admin, marketIndex) {
  return LetOps.AwaitThen.let_(setOracleManagerPrice(longShort, marketIndex, admin), (function (param) {
                return LetOps.AwaitThen.let_(Helpers.increaseTime(5), (function (param) {
                              return longShort.connect(admin).updateSystemState(marketIndex);
                            }));
              }));
}

function mintAndApprove(paymentToken, amount, user, approvedAddress) {
  return LetOps.AwaitThen.let_(paymentToken.mint(user.address, amount), (function (param) {
                return paymentToken.connect(user).approve(approvedAddress, amount);
              }));
}

function mintNextPrice(amount, marketIndex, paymentToken, longShort, user, isLong) {
  return LetOps.AwaitThen.let_(mintAndApprove(paymentToken, amount, user, longShort.address), (function (param) {
                var mintFunction = isLong ? (function (prim0, prim1, prim2) {
                      return prim0.mintLongNextPrice(prim1, prim2);
                    }) : (function (prim0, prim1, prim2) {
                      return prim0.mintShortNextPrice(prim1, prim2);
                    });
                return Curry._3(mintFunction, longShort.connect(user), marketIndex, amount);
              }));
}

function mintLongNextPriceWithSystemUpdate(amount, marketIndex, paymentToken, longShort, user, admin) {
  return LetOps.AwaitThen.let_(mintNextPrice(amount, marketIndex, paymentToken, longShort, user, true), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function mintShortNextPriceWithSystemUpdate(amount, marketIndex, paymentToken, longShort, user, admin) {
  return LetOps.AwaitThen.let_(mintNextPrice(amount, marketIndex, paymentToken, longShort, user, false), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function mintAndStakeNextPriceWithSystemStateUpdate(amount, marketIndex, paymentToken, longShort, user, admin, isLong) {
  return LetOps.AwaitThen.let_(mintAndApprove(paymentToken, amount, user, longShort.address), (function (param) {
                return LetOps.AwaitThen.let_(longShort.connect(user).mintAndStakeNextPrice(marketIndex, amount, isLong), (function (param) {
                              return updateSystemState(longShort, admin, marketIndex);
                            }));
              }));
}

function redeemNextPrice(amount, marketIndex, longShort, user, isLong) {
  var redeemFunction = isLong ? (function (prim0, prim1, prim2) {
        return prim0.redeemLongNextPrice(prim1, prim2);
      }) : (function (prim0, prim1, prim2) {
        return prim0.redeemShortNextPrice(prim1, prim2);
      });
  return Curry._3(redeemFunction, longShort.connect(user), marketIndex, amount);
}

function redeemShortNextPriceWithSystemUpdate(amount, marketIndex, longShort, user, admin) {
  return LetOps.AwaitThen.let_(redeemNextPrice(amount, marketIndex, longShort, user, false), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function redeemLongNextPriceWithSystemUpdate(amount, marketIndex, longShort, user, admin) {
  return LetOps.AwaitThen.let_(redeemNextPrice(amount, marketIndex, longShort, user, true), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function shiftNextPrice(amountSyntheticTokensToShift, marketIndex, longShort, user, isLong) {
  var shiftFunction = isLong ? (function (prim0, prim1, prim2) {
        return prim0.shiftPositionFromLongNextPrice(prim1, prim2);
      }) : (function (prim0, prim1, prim2) {
        return prim0.shiftPositionFromShortNextPrice(prim1, prim2);
      });
  return Curry._3(shiftFunction, longShort.connect(user), marketIndex, amountSyntheticTokensToShift);
}

function shiftFromShortNextPriceWithSystemUpdate(amountSyntheticTokensToShift, marketIndex, longShort, user, admin) {
  return LetOps.AwaitThen.let_(shiftNextPrice(amountSyntheticTokensToShift, marketIndex, longShort, user, false), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function shiftFromLongNextPriceWithSystemUpdate(amountSyntheticTokensToShift, marketIndex, longShort, user, admin) {
  return LetOps.AwaitThen.let_(shiftNextPrice(amountSyntheticTokensToShift, marketIndex, longShort, user, true), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function shiftStakeNextPriceWithSystemUpdate(amount, isShiftFromLong, marketIndex, longShort, staker, user, admin) {
  console.log("Amount to shift is", Globals.bnToString(amount));
  return LetOps.AwaitThen.let_(staker.connect(user).shiftTokens(amount, marketIndex, isShiftFromLong), (function (param) {
                return updateSystemState(longShort, admin, marketIndex);
              }));
}

function stakeSynthLong(amount, longShort, marketIndex, user) {
  return LetOps.AwaitThen.let_(longShort.syntheticTokens(marketIndex, true), (function (longAddress) {
                return LetOps.AwaitThen.let_(SyntheticToken.at(longAddress), (function (synth) {
                              return LetOps.Await.let_(synth.balanceOf(user.address), (function (usersSyntheticTokenBalance) {
                                            if (Globals.bnGt(usersSyntheticTokenBalance, Globals.bnFromString("0"))) {
                                              synth.connect(user).stake(amount);
                                              return ;
                                            }
                                            
                                          }));
                            }));
              }));
}

function executeOnMarkets(marketIndexes, functionToExecute) {
  return Belt_Array.reduce(marketIndexes, Promise.resolve(undefined), (function (previousPromise, marketIndex) {
                return LetOps.AwaitThen.let_(previousPromise, (function (param) {
                              return Curry._1(functionToExecute, marketIndex);
                            }));
              }));
}

function stakeSynthShort(amount, longShort, marketIndex, user) {
  return LetOps.AwaitThen.let_(longShort.syntheticTokens(marketIndex, false), (function (shortAddress) {
                return LetOps.AwaitThen.let_(SyntheticToken.at(shortAddress), (function (synth) {
                              return LetOps.Await.let_(synth.balanceOf(user.address), (function (usersSyntheticTokenBalance) {
                                            if (Globals.bnGt(usersSyntheticTokenBalance, Globals.bnFromString("0"))) {
                                              synth.connect(user).stake(amount);
                                              return ;
                                            }
                                            
                                          }));
                            }));
              }));
}

function withdrawStakeSynthLong(longShort, staker, marketIndex, user) {
  return LetOps.AwaitThen.let_(longShort.syntheticTokens(marketIndex, true), (function (longAddress) {
                return LetOps.Await.let_(staker.userAmountStaked(longAddress, user.address), (function (longStakeBalance) {
                              if (Globals.bnGt(longStakeBalance, Globals.bnFromString("0"))) {
                                staker.connect(user).withdraw(marketIndex, true, longStakeBalance);
                                return ;
                              }
                              
                            }));
              }));
}

function transferSynthLong(longShort, userFrom, userTo, marketIndex) {
  return LetOps.AwaitThen.let_(longShort.syntheticTokens(marketIndex, true), (function (longAddress) {
                return LetOps.AwaitThen.let_(SyntheticToken.at(longAddress), (function (synth) {
                              return LetOps.AwaitThen.let_(synth.balanceOf(userFrom.address), (function (balance) {
                                            return synth.connect(userFrom).transfer(userTo.address, balance.div(Globals.bnFromString("2")));
                                          }));
                            }));
              }));
}

function claimFloatForUser(marketIndexes, staker, user) {
  return LetOps.Await.let_(staker.connect(user).claimFloatCustom(marketIndexes), (function (param) {
                
              }));
}

function updateFloatPercentage(staker, admin, newFloatPercentage) {
  return LetOps.Await.let_(staker.connect(admin).changeFloatPercentage(newFloatPercentage), (function (param) {
                
              }));
}

function updateBalanceIncentiveParameters(staker, admin, marketIndex, balanceIncentiveCurve_exponent, balanceIncentiveCurve_equilibriumOffset, safeExponentBitShifting) {
  return LetOps.Await.let_(staker.connect(admin).changeBalanceIncentiveParameters(marketIndex, balanceIncentiveCurve_exponent, balanceIncentiveCurve_equilibriumOffset, safeExponentBitShifting), (function (param) {
                
              }));
}

function updateStakeWithdrawalFee(staker, admin, marketIndex, newMarketUnstakeFee_e18) {
  return LetOps.Await.let_(staker.connect(admin).changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18), (function (param) {
                
              }));
}

exports.minSenderBalance = minSenderBalance;
exports.minRecieverBalance = minRecieverBalance;
exports.topupBalanceIfLow = topupBalanceIfLow;
exports.setOracleManagerPrice = setOracleManagerPrice;
exports.updateSystemState = updateSystemState;
exports.mintAndApprove = mintAndApprove;
exports.mintNextPrice = mintNextPrice;
exports.mintLongNextPriceWithSystemUpdate = mintLongNextPriceWithSystemUpdate;
exports.mintShortNextPriceWithSystemUpdate = mintShortNextPriceWithSystemUpdate;
exports.mintAndStakeNextPriceWithSystemStateUpdate = mintAndStakeNextPriceWithSystemStateUpdate;
exports.redeemNextPrice = redeemNextPrice;
exports.redeemShortNextPriceWithSystemUpdate = redeemShortNextPriceWithSystemUpdate;
exports.redeemLongNextPriceWithSystemUpdate = redeemLongNextPriceWithSystemUpdate;
exports.shiftNextPrice = shiftNextPrice;
exports.shiftFromShortNextPriceWithSystemUpdate = shiftFromShortNextPriceWithSystemUpdate;
exports.shiftFromLongNextPriceWithSystemUpdate = shiftFromLongNextPriceWithSystemUpdate;
exports.shiftStakeNextPriceWithSystemUpdate = shiftStakeNextPriceWithSystemUpdate;
exports.stakeSynthLong = stakeSynthLong;
exports.executeOnMarkets = executeOnMarkets;
exports.stakeSynthShort = stakeSynthShort;
exports.withdrawStakeSynthLong = withdrawStakeSynthLong;
exports.transferSynthLong = transferSynthLong;
exports.claimFloatForUser = claimFloatForUser;
exports.updateFloatPercentage = updateFloatPercentage;
exports.updateBalanceIncentiveParameters = updateBalanceIncentiveParameters;
exports.updateStakeWithdrawalFee = updateStakeWithdrawalFee;
/* minSenderBalance Not a pure module */

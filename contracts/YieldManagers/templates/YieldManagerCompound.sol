// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.10;

import "../../interfaces/Compound.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "../../interfaces/IYieldManager.sol";
import "../../abstract/AccessControlledAndUpgradeable.sol";
import "../../util/NoRevertERC20.sol";

error CompoundError(string message, uint256 errorCode);

/** @title YieldManagerCompound
  @notice contract is used to manage the yield generated by the underlying tokens.
  YieldManagerCompound is an implementation of a yield manager that earns APY from the Compound protocol.
  Each fund's payment token (such as DAI) has a corresponding cToken (such as aDAI) that
  continuously accrues interest based on a lend/borrow liquidity ratio.
  @dev https://compound.finance/docs
  */
contract YieldManagerCompound is IYieldManager, AccessControlledAndUpgradeable {
  using NoRevertERC20 for IERC20;

  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /// @notice address of longShort contract
  address public longShort;
  /// @notice address of treasury contract - this is the address that can claim compound incentives rewards
  address public treasury;

  /// @notice boolean to prevent markets using an already initialized market
  bool public isInitialized;

  /// @notice The payment token the yield manager supports
  /// @dev DAI token
  IERC20 public paymentToken;
  /// @notice The token representing the interest accruing payment token position from Compound
  /// @dev ADAI token
  CErc20 public cToken;

  /// @notice distributed yield not yet transferred to the treasury
  uint256 public override totalReservedForTreasury;

  /// @dev This value will likely remain zero forever. It exists to handle the rare edge case that Compound doesn't have enough liquidity for a withdrawal.
  ///      In this case this variable would keep track of that so that the withdrawal can happen after the fact when liquidity becomes available.
  uint256 public amountReservedInCaseOfInsufficientYieldProviderLiquidity;

  uint256[45] private __variableGap;

  /// @dev This stores the amount of disposable payment token that isn't yet in Compound that can be used for small withdrawals and deposits
  uint256 public paymentTokenNotInYieldManager;

  /*╔══════════════════════════════════╗
    ║          STATIC GETTERS          ║
    ╚══════════════════════════════════╝*/
  /* 
  Solidity doesn't allow you to override 'constant' variables, so you have to make them into functions!
  These functions are virtual so you can override them easily.
   */

  /// @dev The maximum amount of payment token this contract will allow
  function maxPaymentTokenNotInYieldManagerThreshold() internal pure virtual returns (uint256) {
    return 0;
  }

  /// @dev The desired minimum amount of payment token this contract will target
  function minPaymentTokenNotInYieldManagerTarget() internal pure virtual returns (uint256) {
    return 0;
  }

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  /// @dev only allow longShort contract to execute modified functions
  modifier longShortOnly() {
    require(msg.sender == longShort, "Not longShort");
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  function internalInitialize(
    address _longShort,
    address _treasury,
    address _paymentToken,
    address _cToken,
    address _admin
  ) internal initializer {
    require(
      _longShort != address(0) &&
        _treasury != address(0) &&
        _paymentToken != address(0) &&
        _cToken != address(0) &&
        _admin != address(0)
    );

    require(
      maxPaymentTokenNotInYieldManagerThreshold() > minPaymentTokenNotInYieldManagerTarget(),
      "Thresholds not configured correctly"
    );

    longShort = _longShort;
    treasury = _treasury;

    _AccessControlledAndUpgradeable_init(_admin);

    paymentToken = IERC20(_paymentToken);
    cToken = CErc20(_cToken);
  }

  /**
    @notice Constructor for initializing the compound yield manager with a given payment token and corresponding Compound contracts
    @param _longShort address of the longShort contract
    @param _treasury address of the treasury contract
    @param _paymentToken address of the payment token
    @param _cToken address of the interest accruing token linked to the payment token
    @param _admin admin for the contract
  */
  function initialize(
    address _longShort,
    address _treasury,
    address _paymentToken,
    address _cToken,
    address _admin
  ) external initializer {
    internalInitialize(_longShort, _treasury, _paymentToken, _cToken, _admin);

    // Approve tokens for compound lending pool maximally.
    IERC20(_paymentToken).approve(_cToken, type(uint256).max);
  }

  /*╔════════════════════════╗
    ║     IMPLEMENTATION     ║
    ╚════════════════════════╝*/

  /**
   @notice Allows the LongShort contract to deposit tokens into the compound pool
   @param amount Amount of payment token to deposit
  */
  function depositPaymentToken(uint256 amount) external override longShortOnly {
    // If amountReservedInCaseOfInsufficientYieldProviderLiquidity isn't zero, then efficiently net the difference between the amount
    //    It basically always be zero besides extreme and unlikely situations with compound.
    if (amountReservedInCaseOfInsufficientYieldProviderLiquidity != 0) {
      if (amountReservedInCaseOfInsufficientYieldProviderLiquidity >= amount) {
        amountReservedInCaseOfInsufficientYieldProviderLiquidity -= amount;
        // Return early, nothing to deposit into the lending pool
        return;
      } else {
        amount -= amountReservedInCaseOfInsufficientYieldProviderLiquidity;
        amountReservedInCaseOfInsufficientYieldProviderLiquidity = 0;
      }
    }

    uint256 newPaymentTokenNotInYieldManager = paymentTokenNotInYieldManager + amount;
    // If the added amount doesn't go over the max payment token threshold deposit it all.
    if (newPaymentTokenNotInYieldManager < maxPaymentTokenNotInYieldManagerThreshold()) {
      paymentTokenNotInYieldManager = newPaymentTokenNotInYieldManager;
    } else {
      paymentTokenNotInYieldManager = minPaymentTokenNotInYieldManagerTarget();

      // TODO: do something with this result? Probably ok to ignore.
      uint256 mintResult = cToken.mint(
        newPaymentTokenNotInYieldManager - minPaymentTokenNotInYieldManagerTarget()
      );
      // Mint result is 0 if there is no error.
      //   https://compound.finance/docs/ctokens#error-codes
      if (mintResult != 0) {
        revert CompoundError("Unable to deposit into compound", mintResult);
      }
    }
  }

  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Compound
  /// @param user User to recieve the payout
  /// @param amount Amount of payment token to pay to user
  function transferPaymentTokensToUser(address user, uint256 amount)
    external
    override
    longShortOnly
  {
    if (paymentToken.noRevertTransfer(user, amount)) {
      // If the transfer is successful return early, otherwise try pay the user out with the amountReservedInCaseOfInsufficientAaveLiquidity
      return;
    } else {
      amountReservedInCaseOfInsufficientYieldProviderLiquidity -= amount;

      // If this reverts (ie compound unable to make payout), then the whole transaction will revert. User will have to wait until sufficient liquidity available.
      uint256 redeemResult = cToken.redeemUnderlying(amount);
      // Redeem result is 0 if there is no error.
      //   https://compound.finance/docs/ctokens#error-codes
      if (redeemResult != 0) {
        revert CompoundError("Unable to redeem required amount from compount", redeemResult);
      }

      SafeERC20.safeTransfer(paymentToken, user, amount);
    }
  }

  /// @notice Allows the LongShort contract to redeem cTokens for the payment token
  /// @param amount Amount of payment token to withdraw
  /// @dev This will update the amountReservedInCaseOfInsufficientYieldProviderLiquidity if not enough liquidity is avaiable on compound.
  ///      This means that our system can continue to operate even if there is insufficient liquidity in Compound for any reason.
  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {
    uint256 currentPaymentTokenNotInYieldManager = paymentTokenNotInYieldManager;
    // If the added amount doesn't go over the max payment token threshold deposit it all.
    if (currentPaymentTokenNotInYieldManager < amount) {
      uint256 redeemResult = CErc20(cToken).redeemUnderlying(amount);
      // Redeem result is 0 if there is no error.
      //   https://compound.finance/docs/ctokens#error-codes
      if (redeemResult != 0) {
        // In theory we should only catch `VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH` errors.
        // Safe to revert on all errors, if compound completely blocks withdrawals the amountReservedInCaseOfInsufficientYieldProviderLiquidity can grow until it is fixed without problems.
        amountReservedInCaseOfInsufficientYieldProviderLiquidity += amount;
      }
    } else {
      paymentTokenNotInYieldManager = currentPaymentTokenNotInYieldManager - amount;
    }
  }

  /**
    @notice Calculates and updates the yield allocation to the treasury and the market
    @dev treasuryPercent = 1 - marketPercent
    @param totalValueRealizedForMarket total value of long and short side of the market
    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury
    @return The market allocation of the yield
  */
  function distributeYieldForTreasuryAndReturnMarketAllocation(
    uint256 totalValueRealizedForMarket,
    uint256 treasuryYieldPercent_e18
  ) external override longShortOnly returns (uint256) {
    uint256 totalHeld = cToken.balanceOfUnderlying(address(this)) + paymentTokenNotInYieldManager;
    uint256 _totalReservedForTreasury = totalReservedForTreasury;

    uint256 totalRealized = totalValueRealizedForMarket +
      _totalReservedForTreasury +
      amountReservedInCaseOfInsufficientYieldProviderLiquidity;

    if (totalRealized == totalHeld) {
      return 0;
    }

    // will revert in case totalRealized > totalHeld which should never occur since yield is always possitive with compound.
    uint256 unrealizedYield = totalHeld - totalRealized;

    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / 1e18;
    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;

    totalReservedForTreasury = _totalReservedForTreasury + amountForTreasury;

    emit YieldDistributed(unrealizedYield, treasuryYieldPercent_e18);

    return amountForMarketIncentives;
  }

  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract
  function withdrawTreasuryFunds() external override {
    uint256 amountToWithdrawForTreasury = totalReservedForTreasury;
    totalReservedForTreasury = 0;

    // If this returns a non-zero error code (ie compound unable to make payout), then the whole transaction will revert. User will have to wait until sufficient liquidity available.
    uint256 redeemResult = CErc20(cToken).redeemUnderlying(amountToWithdrawForTreasury);
    // Redeem result is 0 if there is no error.
    //   https://compound.finance/docs/ctokens#error-codes
    if (redeemResult != 0) {
      revert CompoundError("Unable to redeem required amount from compount", redeemResult);
    }

    emit WithdrawTreasuryFunds();
  }

  /// @notice Initializes a specific yield manager to a given market
  function initializeForMarket() external override longShortOnly {
    require(!isInitialized, "Yield Manager is already in use");
    isInitialized = true;
  }

  /// Upgradability - implementation constructor:
  constructor() {
    address deadAddress = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;
    internalInitialize(deadAddress, deadAddress, deadAddress, deadAddress, deadAddress);
  }
}

{
  "language": "Solidity",
  "sources": {
    "contracts/abstract/AccessControlledAndUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nabstract contract AccessControlledAndUpgradeable is\n  Initializable,\n  AccessControlUpgradeable,\n  UUPSUpgradeable\n{\n  bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n  /// @notice Initializes the contract when called by parent initializers.\n  /// @param initialAdmin The initial admin who will hold all roles.\n  function _AccessControlledAndUpgradeable_init(address initialAdmin) internal initializer {\n    __AccessControl_init();\n    __UUPSUpgradeable_init();\n    _AccessControlledAndUpgradeable_init_unchained(initialAdmin);\n  }\n\n  /// @notice Initializes the contract for contracts that already call both __AccessControl_init\n  ///         and _UUPSUpgradeable_init when initializing.\n  /// @param initialAdmin The initial admin who will hold all roles.\n  function _AccessControlledAndUpgradeable_init_unchained(address initialAdmin)\n    internal\n    initializer\n  {\n    require(initialAdmin != address(0));\n    _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(UPGRADER_ROLE, initialAdmin);\n  }\n\n  /// @notice Authorizes an upgrade to a new address.\n  /// @dev Can only be called by addresses wih UPGRADER_ROLE\n  function _authorizeUpgrade(address) internal override onlyRole(UPGRADER_ROLE) {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal initializer {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/YieldManagerAave.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"hardhat/console.sol\";\n\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/aave/ILendingPool.sol\";\nimport \"./interfaces/aave/ILendingPoolAddressesProvider.sol\";\nimport \"./interfaces/aave/IAaveIncentivesController.sol\";\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\n\n/** @title YieldManagerAave\n  @notice contract is used to manage the yield generated by the underlying tokens.\n  YieldManagerAave is an implementation of a yield manager that earns APY from the Aave protocol.\n  Each fund's payment token (such as DAI) has a corresponding aToken (such as aDAI) that\n  continuously accrues interest based on a lend/borrow liquidity ratio.\n  @dev https://docs.aave.com/portal/\n  */\ncontract YieldManagerAave is IYieldManager, AccessControlledAndUpgradeable {\n  /*╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝*/\n\n  /// @notice address of longShort contract\n  address public longShort;\n  /// @notice address of treasury contract - this is the address that can claim aave incentives rewards\n  address public treasury;\n\n  /// @notice boolean to prevent markets using an already initialized market\n  bool public isInitialized;\n\n  /// @notice The payment token the yield manager supports\n  /// @dev DAI token\n  IERC20 public paymentToken;\n  /// @notice The token representing the interest accruing payment token position from Aave\n  /// @dev ADAI token\n  IERC20Upgradeable public aToken;\n  /// @notice The specific Aave lending pool address provider contract\n  ILendingPoolAddressesProvider public lendingPoolAddressesProvider;\n  /// @notice The specific Aave incentives controller contract\n  IAaveIncentivesController public aaveIncentivesController;\n\n  /// @dev An aave specific referralCode that has been a depricated feature. This will be set to 0 for \"no referral\" at deployment\n  uint16 referralCode;\n\n  /// @notice distributed yield not yet transferred to the treasury\n  uint256 public override totalReservedForTreasury;\n\n  /// @dev This value will likely remain zero forever. It exists to handle the rare edge case that Aave doesn't have enough liquidity for a withdrawal.\n  ///      In this case this variable would keep track of that so that the withdrawal can happen after the fact when liquidity becomes available.\n  uint256 public amountReservedInCaseOfInsufficientAaveLiquidity;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  /// @dev only allow longShort contract to execute modified functions\n  modifier longShortOnly() {\n    require(msg.sender == longShort, \"Not longShort\");\n    _;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /**\n    @notice Constructor for initializing the aave yield manager with a given payment token and corresponding Aave contracts\n    @param _longShort address of the longShort contract\n    @param _treasury address of the treasury contract\n    @param _paymentToken address of the payment token\n    @param _aToken address of the interest accruing token linked to the payment token\n    @param _lendingPoolAddressesProvider address of the aave lending pool address provider contract\n    @param _aaveReferralCode unique code for aave referrals\n    @param _admin admin for the contract\n    @dev referral code will be set to 0, depricated Aave feature\n  */\n  function initialize(\n    address _longShort,\n    address _treasury,\n    address _paymentToken,\n    address _aToken,\n    address _lendingPoolAddressesProvider,\n    address _aaveIncentivesController,\n    uint16 _aaveReferralCode,\n    address _admin\n  ) external initializer {\n    require(\n      _longShort != address(0) &&\n        _treasury != address(0) &&\n        _paymentToken != address(0) &&\n        _aToken != address(0) &&\n        _lendingPoolAddressesProvider != address(0) &&\n        _aaveIncentivesController != address(0) &&\n        _admin != address(0)\n    );\n\n    longShort = _longShort;\n    treasury = _treasury;\n\n    _AccessControlledAndUpgradeable_init(_admin);\n\n    referralCode = _aaveReferralCode;\n\n    paymentToken = IERC20(_paymentToken);\n    aToken = IERC20Upgradeable(_aToken);\n    lendingPoolAddressesProvider = ILendingPoolAddressesProvider(_lendingPoolAddressesProvider);\n    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);\n\n    // Approve tokens for aave lending pool maximally.\n    IERC20(_paymentToken).approve(\n      ILendingPoolAddressesProvider(_lendingPoolAddressesProvider).getLendingPool(),\n      type(uint256).max\n    );\n  }\n\n  function updateLatestLendingPoolAddress() external {\n    IERC20(paymentToken).approve(lendingPoolAddressesProvider.getLendingPool(), type(uint256).max);\n  }\n\n  /*╔════════════════════════╗\n    ║     IMPLEMENTATION     ║\n    ╚════════════════════════╝*/\n\n  /**\n   @notice Allows the LongShort contract to deposit tokens into the aave pool\n   @param amount Amount of payment token to deposit\n  */\n  function depositPaymentToken(uint256 amount) external override longShortOnly {\n    // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount\n    //    It basically always be zero besides extreme and unlikely situations with aave.\n    if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {\n      if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {\n        amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n        // Return early, nothing to deposit into the lending pool\n        return;\n      } else {\n        amount -= amountReservedInCaseOfInsufficientAaveLiquidity;\n        amountReservedInCaseOfInsufficientAaveLiquidity = 0;\n      }\n    }\n\n    ILendingPool(lendingPoolAddressesProvider.getLendingPool()).deposit(\n      address(paymentToken),\n      amount,\n      address(this),\n      referralCode\n    );\n  }\n\n  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave\n  /// @param user User to recieve the payout\n  /// @param amount Amount of payment token to pay to user\n  function transferPaymentTokensToUser(address user, uint256 amount)\n    external\n    override\n    longShortOnly\n  {\n    try paymentToken.transfer(user, amount) returns (bool transferSuccess) {\n      if (transferSuccess) {\n        // If the transfer is successful return early, otherwise try pay the user out with the amountReservedInCaseOfInsufficientAaveLiquidity\n        return;\n      }\n    } catch {}\n\n    amountReservedInCaseOfInsufficientAaveLiquidity -= amount;\n\n    // If this reverts (ie aave unable to make payout), then the whole transaction will revert. User will have to wait until sufficient liquidity available.\n    ILendingPool(lendingPoolAddressesProvider.getLendingPool()).withdraw(\n      address(paymentToken),\n      amount,\n      user\n    );\n  }\n\n  /// @notice Allows the LongShort contract to redeem aTokens for the payment token\n  /// @param amount Amount of payment token to withdraw\n  /// @dev This will update the amountReservedInCaseOfInsufficientAaveLiquidity if not enough liquidity is avaiable on aave.\n  ///      This means that our system can continue to operate even if there is insufficient liquidity in Aave for any reason.\n  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {\n    try\n      ILendingPool(lendingPoolAddressesProvider.getLendingPool()).withdraw(\n        address(paymentToken),\n        amount,\n        address(this)\n      )\n    {} catch {\n      // In theory we should only catch `VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH` errors.\n      // Safe to revert on all errors, if aave completely blocks withdrawals the amountReservedInCaseOfInsufficientAaveLiquidity can grow until it is fixed without problems.\n      amountReservedInCaseOfInsufficientAaveLiquidity += amount;\n    }\n  }\n\n  /**\n    @notice Allows for withdrawal of aave rewards to the treasury contract\n    @dev This is specifically implemented to allow withdrawal of aave reward wMatic tokens accrued\n  */\n  function claimAaveRewardsToTreasury() external {\n    IAaveIncentivesController _aaveIncentivesController = IAaveIncentivesController(\n      aaveIncentivesController\n    );\n    uint256 amount = _aaveIncentivesController.getUserUnclaimedRewards(address(this));\n\n    address[] memory aTokenAddresses = new address[](1);\n    aTokenAddresses[0] = address(aToken);\n\n    _aaveIncentivesController.claimRewards(aTokenAddresses, amount, treasury);\n\n    emit ClaimAaveRewardTokenToTreasury(amount);\n  }\n\n  /**\n    @notice Calculates and updates the yield allocation to the treasury and the market\n    @dev treasuryPercent = 1 - marketPercent\n    @param totalValueRealizedForMarket total value of long and short side of the market\n    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury\n    @return The market allocation of the yield\n  */\n  function distributeYieldForTreasuryAndReturnMarketAllocation(\n    uint256 totalValueRealizedForMarket,\n    uint256 treasuryYieldPercent_e18\n  ) external override longShortOnly returns (uint256) {\n    uint256 totalHeld = aToken.balanceOf(address(this));\n    uint256 _totalReservedForTreasury = totalReservedForTreasury;\n\n    uint256 totalRealized = totalValueRealizedForMarket +\n      _totalReservedForTreasury +\n      amountReservedInCaseOfInsufficientAaveLiquidity;\n\n    if (totalRealized == totalHeld) {\n      return 0;\n    }\n\n    // will revert in case totalRealized > totalHeld which should never occur since yield is always possitive with aave.\n    uint256 unrealizedYield = totalHeld - totalRealized;\n\n    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / 1e18;\n    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;\n\n    totalReservedForTreasury = _totalReservedForTreasury + amountForTreasury;\n\n    emit YieldDistributed(unrealizedYield, treasuryYieldPercent_e18);\n\n    return amountForMarketIncentives;\n  }\n\n  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract\n  function withdrawTreasuryFunds() external override {\n    uint256 amountToWithdrawForTreasury = totalReservedForTreasury;\n    totalReservedForTreasury = 0;\n\n    // Redeem aToken for payment tokens.\n    ILendingPool(lendingPoolAddressesProvider.getLendingPool()).withdraw(\n      address(paymentToken),\n      amountToWithdrawForTreasury,\n      treasury\n    );\n\n    emit WithdrawTreasuryFunds();\n  }\n\n  /// @notice Initializes a specific yield manager to a given market\n  function initializeForMarket() external override longShortOnly {\n    require(!isInitialized, \"Yield Manager is already in use\");\n    isInitialized = true;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/IYieldManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\n/// @notice Manages yield accumulation for the LongShort contract. Each market is deployed with its own yield manager to simplify the bookkeeping, as different markets may share a payment token and yield pool.\nabstract contract IYieldManager {\n  event ClaimAaveRewardTokenToTreasury(uint256 amount);\n\n  event YieldDistributed(uint256 unrealizedYield, uint256 treasuryYieldPercent_e18);\n\n  /// @dev This is purely saving some gas, but the subgraph will know how much is due for the treasury at all times - no need to include in event.\n  event WithdrawTreasuryFunds();\n\n  /// @notice distributed yield not yet transferred to the treasury\n  function totalReservedForTreasury() external virtual returns (uint256);\n\n  /// @notice Deposits the given amount of payment tokens into this yield manager.\n  /// @param amount Amount of payment token to deposit\n  function depositPaymentToken(uint256 amount) external virtual;\n\n  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave\n  /// @param user User to recieve the payout\n  /// @param amount Amount of payment token to pay to user\n  function transferPaymentTokensToUser(address user, uint256 amount) external virtual;\n\n  /// @notice Withdraws the given amount of tokens from this yield manager.\n  /// @param amount Amount of payment token to withdraw\n  function removePaymentTokenFromMarket(uint256 amount) external virtual;\n\n  /**    \n    @notice Calculates and updates the yield allocation to the treasury and the market\n    @dev treasuryPercent = 1 - marketPercent\n    @param totalValueRealizedForMarket total value of long and short side of the market\n    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury\n    @return amountForMarketIncentives The market allocation of the yield\n  */\n  function distributeYieldForTreasuryAndReturnMarketAllocation(\n    uint256 totalValueRealizedForMarket,\n    uint256 treasuryYieldPercent_e18\n  ) external virtual returns (uint256 amountForMarketIncentives);\n\n  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract\n  function withdrawTreasuryFunds() external virtual;\n\n  /// @notice Initializes a specific yield manager to a given market\n  function initializeForMarket() external virtual;\n}\n"
    },
    "contracts/interfaces/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.3;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral,\n   *                        to receive as result of the liquidation.\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate,\n   *        which means that too much has been borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral,\n   *                        to receive as result of the liquidation.\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver\n   *           contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds,\n   *                        implementing the IFlashLoanReceiver interface.\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.3;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  // event MarketIdSet(string newMarketId);\n  // event LendingPoolUpdated(address indexed newAddress);\n  // event ConfigurationAdminUpdated(address indexed newAddress);\n  // event EmergencyAdminUpdated(address indexed newAddress);\n  // event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  // event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  // event PriceOracleUpdated(address indexed newAddress);\n  // event LendingRateOracleUpdated(address indexed newAddress);\n  // event ProxyCreated(bytes32 id, address indexed newAddress);\n  // event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  // function getMarketId() external view returns (string memory);\n\n  // function setMarketId(string calldata marketId) external;\n\n  // function setAddress(bytes32 id, address newAddress) external;\n\n  // function setAddressAsProxy(bytes32 id, address impl) external;\n\n  // function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  // function setLendingPoolImpl(address pool) external;\n\n  // function getLendingPoolConfigurator() external view returns (address);\n\n  // function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  // function getLendingPoolCollateralManager() external view returns (address);\n\n  // function setLendingPoolCollateralManager(address manager) external;\n\n  // function getPoolAdmin() external view returns (address);\n\n  // function setPoolAdmin(address admin) external;\n\n  // function getEmergencyAdmin() external view returns (address);\n\n  // function setEmergencyAdmin(address admin) external;\n\n  // function getPriceOracle() external view returns (address);\n\n  // function setPriceOracle(address priceOracle) external;\n\n  // function getLendingRateOracle() external view returns (address);\n\n  // function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/interfaces/aave/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.3;\n\ninterface IAaveIncentivesController {\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.3;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n}\n"
    },
    "contracts/mocks/YieldManagerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\nimport \"../interfaces/IYieldManager.sol\";\nimport \"../interfaces/aave/IAaveIncentivesController.sol\";\n\n/*\n * YieldManagerMock is an implementation of a yield manager that supports\n * configurable, deterministic token yields for testing. Note that the mock\n * needs to be able to mint the underlying token to simulate yield.\n */\ncontract YieldManagerMock is IYieldManager {\n  // Admin contracts.\n  address public admin;\n  address public longShort;\n  address public treasury;\n\n  bool public isInitialized = false;\n\n  // Fixed-precision scale for interest percentages and fees.\n  uint256 public constant TEN_TO_THE_18 = 1e18;\n\n  // Global state.\n  ERC20PresetMinterPauser public token;\n  ERC20PresetMinterPauser public tokenOtherRewardERC20;\n\n  uint256 public override totalReservedForTreasury;\n  uint256 public totalHeld;\n\n  uint256 public yieldRate; // pcnt per sec\n  uint256 public lastSettled; // secs after epoch\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier longShortOnly() {\n    require(msg.sender == longShort, \"Not longShort\");\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  constructor(\n    address _longShort,\n    address _treasury,\n    address _token\n  ) {\n    // Admin contracts.\n    longShort = _longShort;\n    treasury = _treasury;\n\n    // Global state.\n    token = ERC20PresetMinterPauser(_token);\n    lastSettled = block.timestamp;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  /**\n   * Adds the token's accrued yield to the token holdings.\n   */\n  function settle() public {\n    uint256 totalYieldRate = yieldRate * (block.timestamp - lastSettled);\n    uint256 totalYield = (totalHeld * totalYieldRate) / TEN_TO_THE_18;\n\n    lastSettled = block.timestamp;\n    totalHeld = totalHeld + totalYield;\n    if (totalYield > 0) {\n      token.mint(address(this), totalYield);\n    }\n  }\n\n  /**\n   * Adds the given yield percent to the token holdings.\n   */\n  function settleWithYieldPercent(uint256 yieldPercent) external {\n    uint256 totalYield = (totalHeld * yieldPercent) / TEN_TO_THE_18;\n\n    lastSettled = block.timestamp;\n    totalHeld = totalHeld + totalYield;\n    token.mint(address(this), totalYield);\n  }\n\n  /**\n   * Adds the given absolute yield to the token holdings.\n   */\n  function settleWithYieldAbsolute(uint256 totalYield) external {\n    lastSettled = block.timestamp;\n    totalHeld = totalHeld + totalYield;\n    token.mint(address(this), totalYield);\n  }\n\n  /**\n   * Sets the yield percentage per second for the given token.\n   */\n  function setYieldRate(uint256 _yieldRate) external {\n    yieldRate = _yieldRate;\n  }\n\n  function depositPaymentToken(uint256 amount) external override longShortOnly {\n    // Ensure token state is current.\n    settle();\n\n    // Transfer tokens to manager contract.\n    totalHeld = totalHeld + amount;\n  }\n\n  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave\n  /// @param user User to recieve the payout\n  /// @param amount Amount of payment token to pay to user\n  function transferPaymentTokensToUser(address user, uint256 amount)\n    external\n    override\n    longShortOnly\n  {\n    // Transfer tokens back to LongShort contract.\n    token.transfer(user, amount);\n  }\n\n  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {\n    // Ensure token state is current.\n    settle();\n    require(amount <= totalHeld);\n\n    totalHeld = totalHeld - amount;\n  }\n\n  function distributeYieldForTreasuryAndReturnMarketAllocation(\n    uint256 totalValueRealizedForMarket,\n    uint256 treasuryYieldPercent_e18\n  ) external override longShortOnly returns (uint256) {\n    uint256 unrealizedYield = totalHeld - totalValueRealizedForMarket - totalReservedForTreasury;\n\n    if (unrealizedYield == 0) {\n      return 0;\n    }\n\n    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / TEN_TO_THE_18;\n    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;\n\n    totalReservedForTreasury += amountForTreasury;\n\n    return amountForMarketIncentives;\n  }\n\n  function withdrawTreasuryFunds() external override longShortOnly {}\n\n  function initializeForMarket() external override longShortOnly {\n    require(!isInitialized, \"Yield Manager is already in use\");\n    isInitialized = true;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/testing/generated/LongShortMockable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../interfaces/ITokenFactory.sol\";\nimport \"../../interfaces/ISyntheticToken.sol\";\nimport \"../../interfaces/IStaker.sol\";\nimport \"../../interfaces/ILongShort.sol\";\nimport \"../../interfaces/IYieldManager.sol\";\nimport \"../../interfaces/IOracleManager.sol\";\nimport \"../../abstract/AccessControlledAndUpgradeable.sol\";\nimport \"../../GEMS.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./LongShortForInternalMocking.sol\";\nimport \"../LongShortInternalStateSetters.sol\";\n\ncontract LongShortMockable is LongShortInternalStateSetters {\n  LongShortForInternalMocking mocker;\n  bool shouldUseMock;\n  string functionToNotMock;\n\n  function setMocker(LongShortForInternalMocking _mocker) external {\n    mocker = _mocker;\n    shouldUseMock = true;\n  }\n\n  function setFunctionToNotMock(string calldata _functionToNotMock) external {\n    functionToNotMock = _functionToNotMock;\n    shouldUseMock = true;\n  }\n\n  function adminOnlyModifierLogicExposed() external {\n    return super.adminOnlyModifierLogic();\n  }\n\n  function adminOnlyModifierLogic() internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"adminOnlyModifierLogic\"))\n    ) {\n      return mocker.adminOnlyModifierLogicMock();\n    } else {\n      return super.adminOnlyModifierLogic();\n    }\n  }\n\n  function requireMarketExistsModifierLogicExposed(uint32 marketIndex) external view {\n    return super.requireMarketExistsModifierLogic(marketIndex);\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"requireMarketExistsModifierLogic\"))\n    ) {\n      return mocker.requireMarketExistsModifierLogicMock(marketIndex);\n    } else {\n      return super.requireMarketExistsModifierLogic(marketIndex);\n    }\n  }\n\n  function gemCollectingModifierLogicExposed() external {\n    return super.gemCollectingModifierLogic();\n  }\n\n  function gemCollectingModifierLogic() internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"gemCollectingModifierLogic\"))\n    ) {\n      return mocker.gemCollectingModifierLogicMock();\n    } else {\n      return super.gemCollectingModifierLogic();\n    }\n  }\n\n  function _seedMarketInitiallyExposed(\n    uint256 initialMarketSeedForEachMarketSide,\n    uint32 marketIndex\n  ) external {\n    return super._seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex)\n    internal\n    override\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_seedMarketInitially\"))\n    ) {\n      return mocker._seedMarketInitiallyMock(initialMarketSeedForEachMarketSide, marketIndex);\n    } else {\n      return super._seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n    }\n  }\n\n  function _getSyntheticTokenPriceExposed(\n    uint256 amountPaymentTokenBackingSynth,\n    uint256 amountSyntheticToken\n  ) external pure returns (uint256 syntheticTokenPrice) {\n    return super._getSyntheticTokenPrice(amountPaymentTokenBackingSynth, amountSyntheticToken);\n  }\n\n  function _getAmountPaymentTokenExposed(\n    uint256 amountSyntheticToken,\n    uint256 syntheticTokenPriceInPaymentTokens\n  ) external pure returns (uint256 amountPaymentToken) {\n    return super._getAmountPaymentToken(amountSyntheticToken, syntheticTokenPriceInPaymentTokens);\n  }\n\n  function _getAmountSyntheticTokenExposed(\n    uint256 amountPaymentTokenBackingSynth,\n    uint256 syntheticTokenPriceInPaymentTokens\n  ) external pure returns (uint256 amountSyntheticToken) {\n    return\n      super._getAmountSyntheticToken(\n        amountPaymentTokenBackingSynth,\n        syntheticTokenPriceInPaymentTokens\n      );\n  }\n\n  function _getEquivalentAmountSyntheticTokensOnTargetSideExposed(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) external pure returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    return\n      super._getEquivalentAmountSyntheticTokensOnTargetSide(\n        amountSyntheticTokens_originSide,\n        syntheticTokenPrice_originSide,\n        syntheticTokenPrice_targetSide\n      );\n  }\n\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"getAmountSyntheticTokenToMintOnTargetSide\"))\n    ) {\n      return\n        mocker.getAmountSyntheticTokenToMintOnTargetSideMock(\n          marketIndex,\n          amountSyntheticToken_redeemOnOriginSide,\n          isShiftFromLong,\n          priceSnapshotIndex\n        );\n    } else {\n      return\n        super.getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          amountSyntheticToken_redeemOnOriginSide,\n          isShiftFromLong,\n          priceSnapshotIndex\n        );\n    }\n  }\n\n  function _getYieldSplitExposed(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) external view returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    return super._getYieldSplit(marketIndex, longValue, shortValue, totalValueLockedInMarket);\n  }\n\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  )\n    internal\n    view\n    override\n    returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18)\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_getYieldSplit\"))\n    ) {\n      return\n        mocker._getYieldSplitMock(marketIndex, longValue, shortValue, totalValueLockedInMarket);\n    } else {\n      return super._getYieldSplit(marketIndex, longValue, shortValue, totalValueLockedInMarket);\n    }\n  }\n\n  function _claimAndDistributeYieldThenRebalanceMarketExposed(\n    uint32 marketIndex,\n    int256 newAssetPrice\n  ) external returns (uint256 longValue, uint256 shortValue) {\n    return super._claimAndDistributeYieldThenRebalanceMarket(marketIndex, newAssetPrice);\n  }\n\n  function _claimAndDistributeYieldThenRebalanceMarket(uint32 marketIndex, int256 newAssetPrice)\n    internal\n    override\n    returns (uint256 longValue, uint256 shortValue)\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_claimAndDistributeYieldThenRebalanceMarket\"))\n    ) {\n      return mocker._claimAndDistributeYieldThenRebalanceMarketMock(marketIndex, newAssetPrice);\n    } else {\n      return super._claimAndDistributeYieldThenRebalanceMarket(marketIndex, newAssetPrice);\n    }\n  }\n\n  function _updateSystemStateInternalExposed(uint32 marketIndex) external {\n    return super._updateSystemStateInternal(marketIndex);\n  }\n\n  function _updateSystemStateInternal(uint32 marketIndex)\n    internal\n    override\n    requireMarketExists(marketIndex)\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_updateSystemStateInternal\"))\n    ) {\n      return mocker._updateSystemStateInternalMock(marketIndex);\n    } else {\n      return super._updateSystemStateInternal(marketIndex);\n    }\n  }\n\n  function _transferPaymentTokensFromUserToYieldManagerExposed(uint32 marketIndex, uint256 amount)\n    external\n  {\n    return super._transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n  }\n\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount)\n    internal\n    override\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_transferPaymentTokensFromUserToYieldManager\"))\n    ) {\n      return mocker._transferPaymentTokensFromUserToYieldManagerMock(marketIndex, amount);\n    } else {\n      return super._transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n    }\n  }\n\n  function _mintNextPriceExposed(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  ) external {\n    return super._mintNextPrice(marketIndex, amount, isLong);\n  }\n\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    override\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_mintNextPrice\"))\n    ) {\n      return mocker._mintNextPriceMock(marketIndex, amount, isLong);\n    } else {\n      return super._mintNextPrice(marketIndex, amount, isLong);\n    }\n  }\n\n  function _redeemNextPriceExposed(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  ) external {\n    return super._redeemNextPrice(marketIndex, tokens_redeem, isLong);\n  }\n\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    override\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_redeemNextPrice\"))\n    ) {\n      return mocker._redeemNextPriceMock(marketIndex, tokens_redeem, isLong);\n    } else {\n      return super._redeemNextPrice(marketIndex, tokens_redeem, isLong);\n    }\n  }\n\n  function shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    public\n    override\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"shiftPositionNextPrice\"))\n    ) {\n      return\n        mocker.shiftPositionNextPriceMock(\n          marketIndex,\n          amountSyntheticTokensToShift,\n          isShiftFromLong\n        );\n    } else {\n      return\n        super.shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, isShiftFromLong);\n    }\n  }\n\n  function _executeOutstandingNextPriceMintsExposed(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) external {\n    return super._executeOutstandingNextPriceMints(marketIndex, user, isLong);\n  }\n\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_executeOutstandingNextPriceMints\"))\n    ) {\n      return mocker._executeOutstandingNextPriceMintsMock(marketIndex, user, isLong);\n    } else {\n      return super._executeOutstandingNextPriceMints(marketIndex, user, isLong);\n    }\n  }\n\n  function _executeOutstandingNextPriceRedeemsExposed(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) external {\n    return super._executeOutstandingNextPriceRedeems(marketIndex, user, isLong);\n  }\n\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_executeOutstandingNextPriceRedeems\"))\n    ) {\n      return mocker._executeOutstandingNextPriceRedeemsMock(marketIndex, user, isLong);\n    } else {\n      return super._executeOutstandingNextPriceRedeems(marketIndex, user, isLong);\n    }\n  }\n\n  function _executeOutstandingNextPriceTokenShiftsExposed(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) external {\n    return super._executeOutstandingNextPriceTokenShifts(marketIndex, user, isShiftFromLong);\n  }\n\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_executeOutstandingNextPriceTokenShifts\"))\n    ) {\n      return mocker._executeOutstandingNextPriceTokenShiftsMock(marketIndex, user, isShiftFromLong);\n    } else {\n      return super._executeOutstandingNextPriceTokenShifts(marketIndex, user, isShiftFromLong);\n    }\n  }\n\n  function _executeOutstandingNextPriceSettlementsExposed(address user, uint32 marketIndex)\n    external\n  {\n    return super._executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex)\n    internal\n    override\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_executeOutstandingNextPriceSettlements\"))\n    ) {\n      return mocker._executeOutstandingNextPriceSettlementsMock(user, marketIndex);\n    } else {\n      return super._executeOutstandingNextPriceSettlements(user, marketIndex);\n    }\n  }\n\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManagerExposed(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) external {\n    return\n      super._handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n        marketIndex,\n        totalPaymentTokenValueChangeForMarket\n      );\n  }\n\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_handleTotalPaymentTokenValueChangeForMarketWithYieldManager\"))\n    ) {\n      return\n        mocker._handleTotalPaymentTokenValueChangeForMarketWithYieldManagerMock(\n          marketIndex,\n          totalPaymentTokenValueChangeForMarket\n        );\n    } else {\n      return\n        super._handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n          marketIndex,\n          totalPaymentTokenValueChangeForMarket\n        );\n    }\n  }\n\n  function _handleChangeInSyntheticTokensTotalSupplyExposed(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) external {\n    return\n      super._handleChangeInSyntheticTokensTotalSupply(\n        marketIndex,\n        isLong,\n        changeInSyntheticTokensTotalSupply\n      );\n  }\n\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_handleChangeInSyntheticTokensTotalSupply\"))\n    ) {\n      return\n        mocker._handleChangeInSyntheticTokensTotalSupplyMock(\n          marketIndex,\n          isLong,\n          changeInSyntheticTokensTotalSupply\n        );\n    } else {\n      return\n        super._handleChangeInSyntheticTokensTotalSupply(\n          marketIndex,\n          isLong,\n          changeInSyntheticTokensTotalSupply\n        );\n    }\n  }\n\n  function _batchConfirmOutstandingPendingActionsExposed(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    external\n    returns (\n      int256 long_changeInMarketValue_inPaymentToken,\n      int256 short_changeInMarketValue_inPaymentToken\n    )\n  {\n    return\n      super._batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n  }\n\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    override\n    returns (\n      int256 long_changeInMarketValue_inPaymentToken,\n      int256 short_changeInMarketValue_inPaymentToken\n    )\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_batchConfirmOutstandingPendingActions\"))\n    ) {\n      return\n        mocker._batchConfirmOutstandingPendingActionsMock(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        );\n    } else {\n      return\n        super._batchConfirmOutstandingPendingActions(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        );\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/interfaces/ITokenFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\ninterface ITokenFactory {\n  function createSyntheticToken(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address staker,\n    uint32 marketIndex,\n    bool isLong\n  ) external returns (address);\n}\n"
    },
    "contracts/interfaces/ISyntheticToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\n/**\n@title SyntheticToken\n@notice An ERC20 token that tracks or inversely tracks the price of an\n        underlying asset with floating exposure.\n*/\ninterface ISyntheticToken {\n  // function MINTER_ROLE() external returns (bytes32);\n\n  /// @notice Allows users to stake their synthetic tokens to earn Float.\n  function stake(uint256) external;\n\n  function mint(address, uint256) external;\n\n  function totalSupply() external returns (uint256);\n\n  function transferFrom(\n    address,\n    address,\n    uint256\n  ) external returns (bool);\n\n  function transfer(address, uint256) external returns (bool);\n\n  function burn(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IStaker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\ninterface IStaker {\n  /*╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝*/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset,\n    uint256 safeExponentBitShifting\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 multiplier\n  );\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveParamsUpdated(\n    uint32 marketIndex,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 safeExponentBitShifting\n  );\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event NextPriceStakeShift(\n    address user,\n    uint32 marketIndex,\n    uint256 amount,\n    bool isShiftFromLong,\n    uint256 userShiftIndex\n  );\n\n  // only for graph validation\n  event StakeShifted(\n    address user,\n    uint32 marketIndex,\n    uint256 newAmountStakedLong,\n    uint256 newAmountStakedShort\n  );\n\n  function userAmountStaked(address, address) external view returns (uint256);\n\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external;\n\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 marketUpdateIndex,\n    uint256 longTokenPrice,\n    uint256 shortTokenPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) external;\n\n  function stakeFromUser(address from, uint256 amount) external;\n\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external;\n}\n"
    },
    "contracts/interfaces/ILongShort.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\ninterface ILongShort {\n  /*╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝*/\n\n  event LongShortV1(address admin, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    int256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed, uint256 marketLeverage);\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  function syntheticTokens(uint32, bool) external view returns (address);\n\n  function marketUpdateIndex(uint32) external view returns (uint256);\n\n  function syntheticToken_priceSnapshot(\n    uint32,\n    bool,\n    uint256\n  ) external view returns (uint256);\n\n  function marketSideValueInPaymentToken(uint32 marketIndex, bool isLong)\n    external\n    view\n    returns (uint256 marketSideValueInPaymentToken);\n\n  function updateSystemState(uint32 marketIndex) external;\n\n  function updateSystemStateMulti(uint32[] calldata marketIndex) external;\n\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view returns (uint256 confirmedButNotSettledBalance);\n\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external;\n\n  function shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  ) external;\n\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift)\n    external;\n\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift)\n    external;\n\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokenShiftedFromOneSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) external view returns (uint256 amountSynthShiftedToOtherSide);\n\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external;\n\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external;\n\n  function redeemLongNextPrice(uint32 marketIndex, uint256 amount) external;\n\n  function redeemShortNextPrice(uint32 marketIndex, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IOracleManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\n/*\n * Manages price feeds from different oracle implementations.\n */\ninterface IOracleManager {\n  function updatePrice() external returns (int256);\n\n  /*\n   *Returns the latest price from the oracle feed.\n   */\n  function getLatestPrice() external view returns (int256);\n}\n"
    },
    "contracts/GEMS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\n\n/** Contract giving user GEMS*/\n\n// Inspired by https://github.com/andrecronje/rarity/blob/main/rarity.sol\n\n/** @title GEMS */\ncontract GEMS is AccessControlledAndUpgradeable {\n  bytes32 public constant GEM_ROLE = keccak256(\"GEM_ROLE\");\n\n  uint256 constant gems_per_day = 250e18;\n  uint256 constant DAY = 1 days;\n\n  mapping(address => uint256) public gems;\n  mapping(address => uint256) public streak;\n  mapping(address => uint256) public lastAction;\n\n  event GemsCollected(address user, uint256 gems, uint256 streak);\n\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _staker\n  ) external initializer {\n    _AccessControlledAndUpgradeable_init(_admin);\n    _setupRole(GEM_ROLE, _longShort);\n    _setupRole(GEM_ROLE, _staker);\n  }\n\n  // Say gm and get gems by performing an action in LongShort or Staker\n  function gm(address user) external {\n    if (hasRole(GEM_ROLE, msg.sender)) {\n      uint256 usersLastAction = lastAction[user];\n      uint256 blocktimestamp = block.timestamp;\n\n      if (blocktimestamp - usersLastAction >= DAY) {\n        // Award gems\n        gems[user] += gems_per_day;\n\n        // Increment streak\n        if (blocktimestamp - usersLastAction < 2 * DAY) {\n          streak[user] += 1;\n        } else {\n          streak[user] = 1; // reset streak to 1\n        }\n\n        lastAction[user] = blocktimestamp;\n      }\n      emit GemsCollected(user, gems[user], streak[user]);\n    }\n  }\n}\n"
    },
    "contracts/testing/generated/LongShortForInternalMocking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\n\nimport \"./LongShortMockable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../interfaces/ITokenFactory.sol\";\nimport \"../../interfaces/ISyntheticToken.sol\";\nimport \"../../interfaces/IStaker.sol\";\nimport \"../../interfaces/ILongShort.sol\";\nimport \"../../interfaces/IYieldManager.sol\";\nimport \"../../interfaces/IOracleManager.sol\";\nimport \"../../abstract/AccessControlledAndUpgradeable.sol\";\nimport \"../../GEMS.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LongShortForInternalMocking {\n  function adminOnlyModifierLogicMock() public pure {\n    return ();\n  }\n\n  function requireMarketExistsModifierLogicMock(uint32) public pure {\n    return ();\n  }\n\n  function gemCollectingModifierLogicMock() public pure {\n    return ();\n  }\n\n  function initializeMock(\n    address,\n    address,\n    address,\n    address\n  ) public pure {\n    return ();\n  }\n\n  function _seedMarketInitiallyMock(uint256, uint32) public pure {\n    return ();\n  }\n\n  function _getSyntheticTokenPriceMock(uint256, uint256)\n    public\n    pure\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _getAmountPaymentTokenMock(uint256, uint256)\n    public\n    pure\n    returns (uint256 amountPaymentToken)\n  {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _getAmountSyntheticTokenMock(uint256, uint256)\n    public\n    pure\n    returns (uint256 amountSyntheticToken)\n  {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _getEquivalentAmountSyntheticTokensOnTargetSideMock(\n    uint256,\n    uint256,\n    uint256\n  ) public pure returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function getAmountSyntheticTokenToMintOnTargetSideMock(\n    uint32,\n    uint256,\n    bool,\n    uint256\n  ) public pure returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function getUsersConfirmedButNotSettledSynthBalanceMock(\n    address,\n    uint32,\n    bool\n  ) public pure returns (uint256 confirmedButNotSettledBalance) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _getYieldSplitMock(\n    uint32,\n    uint256,\n    uint256,\n    uint256\n  ) public pure returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    return (abi.decode(\"\", (bool)), abi.decode(\"\", (uint256)));\n  }\n\n  function _claimAndDistributeYieldThenRebalanceMarketMock(uint32, int256)\n    public\n    pure\n    returns (uint256 longValue, uint256 shortValue)\n  {\n    return (abi.decode(\"\", (uint256)), abi.decode(\"\", (uint256)));\n  }\n\n  function _updateSystemStateInternalMock(uint32) public pure {\n    return ();\n  }\n\n  function _transferPaymentTokensFromUserToYieldManagerMock(uint32, uint256) public pure {\n    return ();\n  }\n\n  function _mintNextPriceMock(\n    uint32,\n    uint256,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _redeemNextPriceMock(\n    uint32,\n    uint256,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function shiftPositionNextPriceMock(\n    uint32,\n    uint256,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _executeOutstandingNextPriceMintsMock(\n    uint32,\n    address,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _executeOutstandingNextPriceRedeemsMock(\n    uint32,\n    address,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _executeOutstandingNextPriceTokenShiftsMock(\n    uint32,\n    address,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _executeOutstandingNextPriceSettlementsMock(address, uint32) public pure {\n    return ();\n  }\n\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManagerMock(uint32, int256)\n    public\n    pure\n  {\n    return ();\n  }\n\n  function _handleChangeInSyntheticTokensTotalSupplyMock(\n    uint32,\n    bool,\n    int256\n  ) public pure {\n    return ();\n  }\n\n  function _batchConfirmOutstandingPendingActionsMock(\n    uint32,\n    uint256,\n    uint256\n  )\n    public\n    pure\n    returns (\n      int256 long_changeInMarketValue_inPaymentToken,\n      int256 short_changeInMarketValue_inPaymentToken\n    )\n  {\n    return (abi.decode(\"\", (int256)), abi.decode(\"\", (int256)));\n  }\n}\n"
    },
    "contracts/testing/LongShortInternalStateSetters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"../LongShort.sol\";\n\n/*\nNOTE: This contract is for testing purposes only!\n*/\n\ncontract LongShortInternalStateSetters is LongShort {\n  function setInitializeMarketParams(\n    uint32 marketIndex,\n    bool marketIndexValue,\n    uint32 _latestMarket,\n    address _staker,\n    address longAddress,\n    address shortAddress\n  ) public {\n    latestMarket = _latestMarket;\n    marketExists[marketIndex] = marketIndexValue;\n    staker = (_staker);\n    syntheticTokens[marketIndex][\n      true /*short*/\n    ] = (longAddress);\n    syntheticTokens[marketIndex][\n      false /*short*/\n    ] = (shortAddress);\n  }\n\n  function setMarketExistsMulti(uint32[] calldata marketIndexes) external {\n    uint256 length = marketIndexes.length;\n    for (uint256 i = 0; i < length; i++) {\n      marketExists[marketIndexes[i]] = true;\n    }\n  }\n\n  function set_updateSystemStateInternalGlobals(\n    uint32 marketIndex,\n    uint256 _latestUpdateIndexForMarket,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short,\n    int256 _assetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    address oracleManager,\n    address _staker,\n    address synthLong,\n    address synthShort,\n    uint256 stakerNextPrice_currentUpdateIndex\n  ) public {\n    marketExists[marketIndex] = true;\n    marketUpdateIndex[marketIndex] = _latestUpdateIndexForMarket;\n    syntheticToken_priceSnapshot[marketIndex][true][\n      _latestUpdateIndexForMarket\n    ] = syntheticTokenPrice_inPaymentTokens_long;\n    syntheticToken_priceSnapshot[marketIndex][false][\n      _latestUpdateIndexForMarket\n    ] = syntheticTokenPrice_inPaymentTokens_short;\n\n    marketSideValueInPaymentToken[marketIndex][true] = longValue;\n    marketSideValueInPaymentToken[marketIndex][false] = shortValue;\n\n    assetPrice[marketIndex] = _assetPrice;\n    oracleManagers[marketIndex] = oracleManager;\n\n    syntheticTokens[marketIndex][true] = synthLong;\n    syntheticTokens[marketIndex][false] = synthShort;\n\n    staker = _staker;\n\n    userNextPrice_currentUpdateIndex[marketIndex][_staker] = stakerNextPrice_currentUpdateIndex;\n  }\n\n  function setGetUsersConfirmedButNotSettledBalanceGlobals(\n    uint32 marketIndex,\n    address user,\n    bool isLong,\n    uint256 _userNextPrice_currentUpdateIndex,\n    uint256 _marketUpdateIndex,\n    uint256 _userNextPrice_paymentToken_depositAmount_isLong,\n    uint256 _syntheticToken_priceSnapshot_isLong,\n    uint256 _syntheticToken_priceSnapshot_notIsLong,\n    uint256 _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide_notIsLong\n  ) external {\n    marketExists[marketIndex] = true;\n    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;\n    marketUpdateIndex[marketIndex] = _marketUpdateIndex;\n\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][\n      user\n    ] = _userNextPrice_paymentToken_depositAmount_isLong;\n    userNextPrice_paymentToken_depositAmount[marketIndex][!isLong][user] = 0; // reset other side for good measure\n\n    syntheticToken_priceSnapshot[marketIndex][isLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshot_isLong;\n    syntheticToken_priceSnapshot[marketIndex][!isLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshot_notIsLong;\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][\n      user\n    ] = _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide_notIsLong;\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isLong][user] = 0; // reset other side for good measure\n  }\n\n  function setPerformOutstandingBatchedSettlementsGlobals(\n    uint32 marketIndex,\n    uint256 batched_amountPaymentToken_depositLong,\n    uint256 batched_amountPaymentToken_depositShort,\n    uint256 batched_amountSyntheticToken_redeemLong,\n    uint256 batched_amountSyntheticToken_redeemShort,\n    uint256 batchedAmountSyntheticTokenToShiftFromLong,\n    uint256 batchedAmountSyntheticTokenToShiftFromShort\n  ) external {\n    batched_amountPaymentToken_deposit[marketIndex][true] = batched_amountPaymentToken_depositLong;\n    batched_amountPaymentToken_deposit[marketIndex][\n      false\n    ] = batched_amountPaymentToken_depositShort;\n    batched_amountSyntheticToken_redeem[marketIndex][\n      true\n    ] = batched_amountSyntheticToken_redeemLong;\n    batched_amountSyntheticToken_redeem[marketIndex][\n      false\n    ] = batched_amountSyntheticToken_redeemShort;\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      true\n    ] = batchedAmountSyntheticTokenToShiftFromLong;\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ] = batchedAmountSyntheticTokenToShiftFromShort;\n  }\n\n  function setHandleChangeInSyntheticTokensTotalSupplyGlobals(\n    uint32 marketIndex,\n    address longSyntheticToken,\n    address shortSyntheticToken\n  ) external {\n    syntheticTokens[marketIndex][true] = longSyntheticToken;\n    syntheticTokens[marketIndex][false] = shortSyntheticToken;\n  }\n\n  function setRedeemNextPriceGlobals(\n    uint32 marketIndex,\n    uint256 _marketUpdateIndex,\n    address syntheticToken,\n    bool isLong\n  ) external {\n    marketUpdateIndex[marketIndex] = _marketUpdateIndex;\n    syntheticTokens[marketIndex][isLong] = syntheticToken;\n  }\n\n  function setShiftNextPriceGlobals(\n    uint32 marketIndex,\n    uint256 _marketUpdateIndex,\n    address syntheticTokenShiftedFrom,\n    bool isShiftFromLong\n  ) external {\n    marketUpdateIndex[marketIndex] = _marketUpdateIndex;\n    syntheticTokens[marketIndex][isShiftFromLong] = syntheticTokenShiftedFrom;\n  }\n\n  function setExecuteOutstandingNextPriceMintsGlobals(\n    uint32 marketIndex,\n    address user,\n    bool isLong,\n    address syntheticToken,\n    uint256 _userNextPrice_syntheticToken_redeemAmount,\n    uint256 _userNextPrice_currentUpdateIndex,\n    uint256 _syntheticToken_priceSnapshot\n  ) external {\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][\n      user\n    ] = _userNextPrice_syntheticToken_redeemAmount;\n    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;\n    syntheticToken_priceSnapshot[marketIndex][isLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshot;\n    syntheticTokens[marketIndex][isLong] = syntheticToken;\n  }\n\n  function setExecuteOutstandingNextPriceRedeemsGlobals(\n    uint32 marketIndex,\n    address user,\n    bool isLong,\n    address yieldManager,\n    uint256 _userNextPrice_syntheticToken_redeemAmount,\n    uint256 _userNextPrice_currentUpdateIndex,\n    uint256 _syntheticToken_priceSnapshot\n  ) external {\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][\n      user\n    ] = _userNextPrice_syntheticToken_redeemAmount;\n    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;\n    syntheticToken_priceSnapshot[marketIndex][isLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshot;\n    yieldManagers[marketIndex] = yieldManager;\n  }\n\n  function setExecuteOutstandingNextPriceTokenShiftsGlobals(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong,\n    address syntheticTokenShiftedTo,\n    uint256 _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide,\n    uint256 _userNextPrice_currentUpdateIndex,\n    uint256 _syntheticToken_priceSnapshotShiftedFrom,\n    uint256 _syntheticToken_priceSnapshotShiftedTo\n  ) external {\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      user\n    ] = _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;\n    syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshotShiftedFrom;\n    syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      _userNextPrice_currentUpdateIndex\n    ] = _syntheticToken_priceSnapshotShiftedTo;\n    syntheticTokens[marketIndex][!isShiftFromLong] = syntheticTokenShiftedTo;\n  }\n\n  function setExecuteOutstandingNextPriceSettlementsGlobals(\n    uint32 marketIndex,\n    address user,\n    uint256 _userNextPrice_currentUpdateIndex,\n    uint256 _marketUpdateIndex\n  ) external {\n    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;\n    marketUpdateIndex[marketIndex] = _marketUpdateIndex;\n  }\n\n  function setClaimAndDistributeYieldThenRebalanceMarketGlobals(\n    uint32 marketIndex,\n    uint256 _marketSideValueInPaymentTokenLong,\n    uint256 _marketSideValueInPaymentTokenShort,\n    address yieldManager\n  ) external {\n    marketSideValueInPaymentToken[marketIndex][true] = _marketSideValueInPaymentTokenLong;\n    marketSideValueInPaymentToken[marketIndex][false] = _marketSideValueInPaymentTokenShort;\n    yieldManagers[marketIndex] = yieldManager;\n  }\n\n  function setDepositFundsGlobals(\n    uint32 marketIndex,\n    address paymentToken,\n    address yieldManager\n  ) external {\n    paymentTokens[marketIndex] = paymentToken;\n    yieldManagers[marketIndex] = yieldManager;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/LongShort.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/IOracleManager.sol\";\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\nimport \"./GEMS.sol\";\n\n/**\n **** visit https://float.capital *****\n */\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, AccessControlledAndUpgradeable {\n  //Using Open Zeppelin safe transfer library for token transfers\n  using SafeERC20 for IERC20;\n\n  /*╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝*/\n\n  /* ══════ Fixed-precision constants ══════ */\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER =\n    0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  /* ══════ Global state ══════ */\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  address public gems;\n\n  uint256[45] private __globalStateGap;\n\n  /* ══════ Market specific ══════ */\n  mapping(uint32 => bool) public marketExists;\n\n  mapping(uint32 => int256) public assetPrice;\n  mapping(uint32 => uint256) public override marketUpdateIndex;\n  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;\n  mapping(uint32 => uint256) public marketLeverage_e18;\n\n  mapping(uint32 => address) public paymentTokens;\n  mapping(uint32 => address) public yieldManagers;\n  mapping(uint32 => address) public oracleManagers;\n  uint256[45] private __marketStateGap;\n\n  /* ══════ Market + position (long/short) specific ══════ */\n  mapping(uint32 => mapping(bool => address)) public override syntheticTokens;\n  mapping(uint32 => mapping(bool => uint256)) public override marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 => mapping(bool => mapping(uint256 => uint256)))\n    public\n    override syntheticToken_priceSnapshot;\n\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 => mapping(bool => uint256))\n    public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n  uint256[45] private __marketPositonStateGap;\n\n  /* ══════ User specific ══════ */\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function adminOnlyModifierLogic() internal virtual {\n    _checkRole(ADMIN_ROLE, msg.sender);\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    _;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], \"market doesn't exist\");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    _;\n  }\n\n  modifier updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(\n    address user,\n    uint32 marketIndex\n  ) {\n    _updateSystemStateInternal(marketIndex);\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n    _;\n  }\n\n  function gemCollectingModifierLogic() internal virtual {\n    if (msg.sender != staker) {\n      GEMS(gems).gm(msg.sender);\n    }\n  }\n\n  modifier gemCollecting() {\n    gemCollectingModifierLogic();\n    _;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin's initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _tokenFactory,\n    address _staker,\n    address _gems\n  ) external virtual initializer {\n    require(\n      _admin != address(0) &&\n        _tokenFactory != address(0) &&\n        _staker != address(0) &&\n        _gems != address(0)\n    );\n    _AccessControlledAndUpgradeable_init(_admin);\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n    gems = _gems;\n\n    emit LongShortV1(_admin, _tokenFactory, _staker);\n  }\n\n  /*╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(\n    uint32 marketIndex,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝*/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    require(\n      _paymentToken != address(0) && _oracleManager != address(0) && _yieldManager != address(0)\n    );\n\n    uint32 marketIndex = ++latestMarket;\n    address _staker = staker;\n\n    // Ensure new markets don't use the same yield manager\n    IYieldManager(_yieldManager).initializeForMarket();\n\n    // Create new synthetic long token.\n    syntheticTokens[marketIndex][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Long \", syntheticName)),\n      string(abi.encodePacked(\"fl\", syntheticSymbol)),\n      _staker,\n      marketIndex,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[marketIndex][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Short \", syntheticName)),\n      string(abi.encodePacked(\"fs\", syntheticSymbol)),\n      _staker,\n      marketIndex,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[marketIndex] = _paymentToken;\n    yieldManagers[marketIndex] = _yieldManager;\n    oracleManagers[marketIndex] = _oracleManager;\n    assetPrice[marketIndex] = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n\n    emit SyntheticMarketCreated(\n      marketIndex,\n      syntheticTokens[marketIndex][true],\n      syntheticTokens[marketIndex][false],\n      _paymentToken,\n      assetPrice[marketIndex],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Uses already created synthetic tokens.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _longToken Address for the long token.\n  /// @param _shortToken Address for the short token.\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarketExternalSyntheticTokens(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _longToken,\n    address _shortToken,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    uint32 marketIndex = ++latestMarket;\n\n    // Ensure new markets don't use the same yield manager\n    IYieldManager(_yieldManager).initializeForMarket();\n\n    // Assign new synthetic long token.\n    syntheticTokens[marketIndex][true] = _longToken;\n\n    // Assign new synthetic short token.\n    syntheticTokens[marketIndex][false] = _shortToken;\n\n    // Initial market state.\n    paymentTokens[marketIndex] = _paymentToken;\n    yieldManagers[marketIndex] = _yieldManager;\n    oracleManagers[marketIndex] = _oracleManager;\n    assetPrice[marketIndex] = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n\n    emit SyntheticMarketCreated(\n      marketIndex,\n      _longToken,\n      _shortToken,\n      _paymentToken,\n      assetPrice[marketIndex],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex)\n    internal\n    virtual\n  {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide >= 1e18,\n      \"Insufficient market seed\"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[marketIndex][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[marketIndex][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18,\n    uint256 marketLeverage\n  ) external adminOnly {\n    require(\n      kInitialMultiplier != 0 &&\n        unstakeFee_e18 != 0 &&\n        initialMarketSeedForEachMarketSide != 0 &&\n        balanceIncentiveCurve_exponent != 0 &&\n        _marketTreasurySplitGradient_e18 != 0\n    );\n\n    require(!marketExists[marketIndex], \"already initialized\");\n    require(marketIndex <= latestMarket, \"index too high\");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n\n    marketLeverage_e18[marketIndex] = marketLeverage;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      marketIndex,\n      syntheticTokens[marketIndex][true],\n      syntheticTokens[marketIndex][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n      marketIndex,\n      1,\n      1e18,\n      1e18,\n      initialMarketSeedForEachMarketSide,\n      initialMarketSeedForEachMarketSide\n    );\n\n    emit NewMarketLaunchedAndSeeded(\n      marketIndex,\n      initialMarketSeedForEachMarketSide,\n      marketLeverage\n    );\n  }\n\n  /*╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝*/\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(\n    uint256 amountPaymentTokenBackingSynth,\n    uint256 amountSyntheticToken\n  ) internal pure virtual returns (uint256 syntheticTokenPrice) {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.\n  function _getAmountPaymentToken(\n    uint256 amountSyntheticToken,\n    uint256 syntheticTokenPriceInPaymentTokens\n  ) internal pure virtual returns (uint256 amountPaymentToken) {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(\n    uint256 amountPaymentTokenBackingSynth,\n    uint256 syntheticTokenPriceInPaymentTokens\n  ) internal pure virtual returns (uint256 amountSyntheticToken) {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /**\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side's synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side's synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  */\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][\n      isShiftFromLong\n    ][priceSnapshotIndex];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][\n      !isShiftFromLong\n    ][priceSnapshotIndex];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /**\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - \"Pending\" - means the next price update hasn't happened or been enacted on by the updateSystemState function.\n        - \"Confirmed\" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - \"Settled\" - there is no more computation left for the user.\n        - \"Non-existent\" - user has no next price actions.\n    This function returns a calculated value only in the case of 'confirmed' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An uint32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  */\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  )\n    external\n    view\n    virtual\n    override\n    requireMarketExists(marketIndex)\n    returns (uint256 confirmedButNotSettledBalance)\n  {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    uint256 userNextPrice_currentUpdateIndex_forMarket = userNextPrice_currentUpdateIndex[\n      marketIndex\n    ][user];\n    if (\n      userNextPrice_currentUpdateIndex_forMarket != 0 &&\n      userNextPrice_currentUpdateIndex_forMarket <= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][\n        isLong\n      ][user];\n\n      if (amountPaymentTokenDeposited > 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][\n          userNextPrice_currentUpdateIndex_forMarket\n        ];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(\n          amountPaymentTokenDeposited,\n          syntheticTokenPrice\n        );\n      }\n\n      uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n          marketIndex\n        ][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][\n          !isLong\n        ][userNextPrice_currentUpdateIndex_forMarket];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          userNextPrice_currentUpdateIndex_forMarket\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /**\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   */\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue < shortValue;\n    uint256 imbalance;\n\n    unchecked {\n      if (isLongSideUnderbalanced) {\n        imbalance = shortValue - longValue;\n      } else {\n        imbalance = longValue - shortValue;\n      }\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://ipfs.io/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance *\n      marketTreasurySplitGradient_e18[marketIndex]) / totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = Math.min(marketPercentCalculated_e18, 1e18);\n\n    unchecked {\n      treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n    }\n  }\n\n  /*╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝*/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(uint32 marketIndex, int256 newAssetPrice)\n    internal\n    virtual\n    returns (uint256 longValue, uint256 shortValue)\n  {\n    int256 oldAssetPrice = assetPrice[marketIndex];\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n      .distributeYieldForTreasuryAndReturnMarketAllocation(\n        totalValueLockedInMarket,\n        treasuryYieldPercent_e18\n      );\n\n    if (marketAmount > 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure < 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(Math.min(longValue, shortValue));\n\n    // See this equation in latex: https://ipfs.io/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) *\n      underbalancedSideValue *\n      int256(marketLeverage_e18[marketIndex])) / (oldAssetPrice * 1e18);\n\n    if (valueChange < 0) {\n      valueChange = -valueChange; // make value change positive\n\n      // handle 'impossible' edge case where underlying price feed changes more than 100% downwards gracefully.\n      if (uint256(valueChange) > longValue) {\n        valueChange = (int256(longValue) * 99999) / 100000;\n      }\n      longValue -= uint256(valueChange);\n      shortValue += uint256(valueChange);\n    } else {\n      // handle 'impossible' edge case where underlying price feed changes more than 100% upwards gracefully.\n      if (uint256(valueChange) > shortValue) {\n        valueChange = (int256(shortValue) * 99999) / 100000;\n      }\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    }\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex)\n    internal\n    virtual\n    requireMarketExists(marketIndex)\n  {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n\n    uint256 currentMarketIndex = marketUpdateIndex[marketIndex];\n\n    bool assetPriceHasChanged = assetPrice[marketIndex] != newAssetPrice;\n\n    if (assetPriceHasChanged) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][\n        true\n      ][currentMarketIndex];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][\n        false\n      ][currentMarketIndex];\n      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n\n      (\n        uint256 newLongPoolValue,\n        uint256 newShortPoolValue\n      ) = _claimAndDistributeYieldThenRebalanceMarket(marketIndex, newAssetPrice);\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = newAssetPrice;\n\n      currentMarketIndex++;\n      marketUpdateIndex[marketIndex] = currentMarketIndex;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        currentMarketIndex\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        currentMarketIndex\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        );\n\n      newLongPoolValue = uint256(\n        int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken\n      );\n      newShortPoolValue = uint256(\n        int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken\n      );\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n        marketIndex,\n        currentMarketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short,\n        newLongPoolValue,\n        newShortPoolValue\n      );\n\n      emit SystemStateUpdated(\n        marketIndex,\n        currentMarketIndex,\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    uint256 length = marketIndexes.length;\n    for (uint256 i = 0; i < length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /*╔═══════════════════════════╗\n    ║          DEPOSIT          ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount)\n    internal\n    virtual\n  {\n    IERC20(paymentTokens[marketIndex]).safeTransferFrom(\n      msg.sender,\n      yieldManagers[marketIndex],\n      amount\n    );\n  }\n\n  /*╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    uint256 nextUpdateIndex = marketUpdateIndex[marketIndex] + 1;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = nextUpdateIndex;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, nextUpdateIndex);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external override {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external override {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /*╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(\n      msg.sender,\n      address(this),\n      tokens_redeem\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    uint256 nextUpdateIndex = marketUpdateIndex[marketIndex] + 1;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = nextUpdateIndex;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, nextUpdateIndex);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external override {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external override {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /*╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    public\n    virtual\n    override\n    updateSystemStateMarketAndExecuteOutstandingNextPriceSettlements(msg.sender, marketIndex)\n    gemCollecting\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    uint256 nextUpdateIndex = marketUpdateIndex[marketIndex] + 1;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = nextUpdateIndex;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      nextUpdateIndex\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift)\n    external\n    override\n  {\n    shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift)\n    external\n    override\n  {\n    shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /*╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝*/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[\n      marketIndex\n    ][isLong][user];\n    if (currentPaymentTokenDepositAmount > 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][\n          userNextPrice_currentUpdateIndex[marketIndex][user]\n        ]\n      );\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(\n        user,\n        amountSyntheticTokensToTransferToUser\n      );\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[\n      marketIndex\n    ][isLong][user];\n    if (currentSyntheticTokenRedemptions > 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][\n          userNextPrice_currentUpdateIndex[marketIndex][user]\n        ]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(\n        user,\n        amountPaymentToken_toRedeem\n      );\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n        marketIndex\n      ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n        user\n      ] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex)\n    internal\n    virtual\n  {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex)\n    external\n    override\n  {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(\n    address user,\n    uint32[] memory marketIndexes\n  ) external {\n    uint256 length = marketIndexes.length;\n    for (uint256 i = 0; i < length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /*╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,\n  /// and vice versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket > 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(\n        uint256(totalPaymentTokenValueChangeForMarket)\n      );\n    } else if (totalPaymentTokenValueChangeForMarket < 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply > 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply < 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(\n        uint256(-changeInSyntheticTokensTotalSupply)\n      );\n    }\n  }\n\n  /**\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An uint32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (\n      int256 long_changeInMarketValue_inPaymentToken,\n      int256 short_changeInMarketValue_inPaymentToken\n    )\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are reusing amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[\n      marketIndex\n    ][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][true];\n\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][false];\n    if (amountForCurrentAction_workingVariable > 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable > 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable > 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(\n      marketIndex,\n      true,\n      changeInSupply_syntheticToken_long\n    );\n    _handleChangeInSyntheticTokensTotalSupply(\n      marketIndex,\n      false,\n      changeInSupply_syntheticToken_short\n    );\n  }\n}\n"
    },
    "contracts/testing/generated/StakerMockable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"../../abstract/AccessControlledAndUpgradeable.sol\";\nimport \"../../interfaces/IFloatToken.sol\";\nimport \"../../interfaces/ILongShort.sol\";\nimport \"../../interfaces/IStaker.sol\";\nimport \"../../interfaces/ISyntheticToken.sol\";\nimport \"../../GEMS.sol\";\nimport \"hardhat/console.sol\";\n\nimport \"./StakerForInternalMocking.sol\";\nimport \"../StakerInternalStateSetters.sol\";\n\ncontract StakerMockable is StakerInternalStateSetters {\n  StakerForInternalMocking mocker;\n  bool shouldUseMock;\n  string functionToNotMock;\n\n  function setMocker(StakerForInternalMocking _mocker) external {\n    mocker = _mocker;\n    shouldUseMock = true;\n  }\n\n  function setFunctionToNotMock(string calldata _functionToNotMock) external {\n    functionToNotMock = _functionToNotMock;\n    shouldUseMock = true;\n  }\n\n  function onlyAdminModifierLogicExposed() external {\n    return super.onlyAdminModifierLogic();\n  }\n\n  function onlyAdminModifierLogic() internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"onlyAdminModifierLogic\"))\n    ) {\n      return mocker.onlyAdminModifierLogicMock();\n    } else {\n      return super.onlyAdminModifierLogic();\n    }\n  }\n\n  function onlyValidSyntheticModifierLogicExposed(address _synth) external {\n    return super.onlyValidSyntheticModifierLogic(_synth);\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"onlyValidSyntheticModifierLogic\"))\n    ) {\n      return mocker.onlyValidSyntheticModifierLogicMock(_synth);\n    } else {\n      return super.onlyValidSyntheticModifierLogic(_synth);\n    }\n  }\n\n  function onlyLongShortModifierLogicExposed() external {\n    return super.onlyLongShortModifierLogic();\n  }\n\n  function onlyLongShortModifierLogic() internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"onlyLongShortModifierLogic\"))\n    ) {\n      return mocker.onlyLongShortModifierLogicMock();\n    } else {\n      return super.onlyLongShortModifierLogic();\n    }\n  }\n\n  function _updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShiftsExposed(\n    uint32 marketIndex,\n    address user\n  ) external {\n    return\n      super._updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n        marketIndex,\n        user\n      );\n  }\n\n  function _updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n    uint32 marketIndex,\n    address user\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(\n        abi.encodePacked(\n          \"_updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts\"\n        )\n      )\n    ) {\n      return\n        mocker._updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShiftsMock(\n          marketIndex,\n          user\n        );\n    } else {\n      return\n        super._updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n          marketIndex,\n          user\n        );\n    }\n  }\n\n  function _changeFloatPercentageExposed(uint256 newFloatPercentage) external {\n    return super._changeFloatPercentage(newFloatPercentage);\n  }\n\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_changeFloatPercentage\"))\n    ) {\n      return mocker._changeFloatPercentageMock(newFloatPercentage);\n    } else {\n      return super._changeFloatPercentage(newFloatPercentage);\n    }\n  }\n\n  function _changeUnstakeFeeExposed(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external {\n    return super._changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18)\n    internal\n    override\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_changeUnstakeFee\"))\n    ) {\n      return mocker._changeUnstakeFeeMock(marketIndex, newMarketUnstakeFee_e18);\n    } else {\n      return super._changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    }\n  }\n\n  function _changeBalanceIncentiveParametersExposed(\n    uint32 marketIndex,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset,\n    uint256 _safeExponentBitShifting\n  ) external {\n    return\n      super._changeBalanceIncentiveParameters(\n        marketIndex,\n        _balanceIncentiveCurve_exponent,\n        _balanceIncentiveCurve_equilibriumOffset,\n        _safeExponentBitShifting\n      );\n  }\n\n  function _changeBalanceIncentiveParameters(\n    uint32 marketIndex,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset,\n    uint256 _safeExponentBitShifting\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_changeBalanceIncentiveParameters\"))\n    ) {\n      return\n        mocker._changeBalanceIncentiveParametersMock(\n          marketIndex,\n          _balanceIncentiveCurve_exponent,\n          _balanceIncentiveCurve_equilibriumOffset,\n          _safeExponentBitShifting\n        );\n    } else {\n      return\n        super._changeBalanceIncentiveParameters(\n          marketIndex,\n          _balanceIncentiveCurve_exponent,\n          _balanceIncentiveCurve_equilibriumOffset,\n          _safeExponentBitShifting\n        );\n    }\n  }\n\n  function _getMarketLaunchIncentiveParametersExposed(uint32 marketIndex)\n    external\n    view\n    returns (uint256 period, uint256 multiplier)\n  {\n    return super._getMarketLaunchIncentiveParameters(marketIndex);\n  }\n\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    override\n    returns (uint256 period, uint256 multiplier)\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_getMarketLaunchIncentiveParameters\"))\n    ) {\n      return mocker._getMarketLaunchIncentiveParametersMock(marketIndex);\n    } else {\n      return super._getMarketLaunchIncentiveParameters(marketIndex);\n    }\n  }\n\n  function _getKValueExposed(uint32 marketIndex) external view returns (uint256) {\n    return super._getKValue(marketIndex);\n  }\n\n  function _getKValue(uint32 marketIndex) internal view override returns (uint256) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(\"_getKValue\"))\n    ) {\n      return mocker._getKValueMock(marketIndex);\n    } else {\n      return super._getKValue(marketIndex);\n    }\n  }\n\n  function _calculateFloatPerSecondExposed(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) external view returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    return\n      super._calculateFloatPerSecond(marketIndex, longPrice, shortPrice, longValue, shortValue);\n  }\n\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view override returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_calculateFloatPerSecond\"))\n    ) {\n      return\n        mocker._calculateFloatPerSecondMock(\n          marketIndex,\n          longPrice,\n          shortPrice,\n          longValue,\n          shortValue\n        );\n    } else {\n      return\n        super._calculateFloatPerSecond(marketIndex, longPrice, shortPrice, longValue, shortValue);\n    }\n  }\n\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotExposed(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex\n  ) external view returns (uint256 timeDelta) {\n    return\n      super._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(\n        marketIndex,\n        previousMarketUpdateIndex\n      );\n  }\n\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex\n  ) internal view override returns (uint256 timeDelta) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(\n        abi.encodePacked(\"_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot\")\n      )\n    ) {\n      return\n        mocker._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotMock(\n          marketIndex,\n          previousMarketUpdateIndex\n        );\n    } else {\n      return\n        super._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(\n          marketIndex,\n          previousMarketUpdateIndex\n        );\n    }\n  }\n\n  function _calculateNewCumulativeIssuancePerStakedSynthExposed(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) external view returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    return\n      super._calculateNewCumulativeIssuancePerStakedSynth(\n        marketIndex,\n        previousMarketUpdateIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n  }\n\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view override returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_calculateNewCumulativeIssuancePerStakedSynth\"))\n    ) {\n      return\n        mocker._calculateNewCumulativeIssuancePerStakedSynthMock(\n          marketIndex,\n          previousMarketUpdateIndex,\n          longPrice,\n          shortPrice,\n          longValue,\n          shortValue\n        );\n    } else {\n      return\n        super._calculateNewCumulativeIssuancePerStakedSynth(\n          marketIndex,\n          previousMarketUpdateIndex,\n          longPrice,\n          shortPrice,\n          longValue,\n          shortValue\n        );\n    }\n  }\n\n  function _calculateAccumulatedFloatInRangeExposed(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) external view returns (uint256 floatReward) {\n    return\n      super._calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        rewardIndexFrom,\n        rewardIndexTo\n      );\n  }\n\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view override returns (uint256 floatReward) {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_calculateAccumulatedFloatInRange\"))\n    ) {\n      return\n        mocker._calculateAccumulatedFloatInRangeMock(\n          marketIndex,\n          amountStakedLong,\n          amountStakedShort,\n          rewardIndexFrom,\n          rewardIndexTo\n        );\n    } else {\n      return\n        super._calculateAccumulatedFloatInRange(\n          marketIndex,\n          amountStakedLong,\n          amountStakedShort,\n          rewardIndexFrom,\n          rewardIndexTo\n        );\n    }\n  }\n\n  function _calculateAccumulatedFloatAndExecuteOutstandingShiftsExposed(\n    uint32 marketIndex,\n    address user\n  ) external returns (uint256 floatReward) {\n    return super._calculateAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n  }\n\n  function _calculateAccumulatedFloatAndExecuteOutstandingShifts(uint32 marketIndex, address user)\n    internal\n    override\n    returns (uint256 floatReward)\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_calculateAccumulatedFloatAndExecuteOutstandingShifts\"))\n    ) {\n      return mocker._calculateAccumulatedFloatAndExecuteOutstandingShiftsMock(marketIndex, user);\n    } else {\n      return super._calculateAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n    }\n  }\n\n  function _mintFloatExposed(address user, uint256 floatToMint) external {\n    return super._mintFloat(user, floatToMint);\n  }\n\n  function _mintFloat(address user, uint256 floatToMint) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(\"_mintFloat\"))\n    ) {\n      return mocker._mintFloatMock(user, floatToMint);\n    } else {\n      return super._mintFloat(user, floatToMint);\n    }\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsExposed(uint32 marketIndex, address user)\n    external\n  {\n    return super._mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShifts(uint32 marketIndex, address user)\n    internal\n    override\n  {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_mintAccumulatedFloatAndExecuteOutstandingShifts\"))\n    ) {\n      return mocker._mintAccumulatedFloatAndExecuteOutstandingShiftsMock(marketIndex, user);\n    } else {\n      return super._mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n    }\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsMultiExposed(\n    uint32[] calldata marketIndexes,\n    address user\n  ) external {\n    return super._mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(marketIndexes, user);\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(\n    uint32[] calldata marketIndexes,\n    address user\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) !=\n      keccak256(abi.encodePacked(\"_mintAccumulatedFloatAndExecuteOutstandingShiftsMulti\"))\n    ) {\n      return mocker._mintAccumulatedFloatAndExecuteOutstandingShiftsMultiMock(marketIndexes, user);\n    } else {\n      return super._mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(marketIndexes, user);\n    }\n  }\n\n  function _withdrawExposed(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) external {\n    return super._withdraw(marketIndex, token, amount);\n  }\n\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal override {\n    if (\n      shouldUseMock &&\n      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(\"_withdraw\"))\n    ) {\n      return mocker._withdrawMock(marketIndex, token, amount);\n    } else {\n      return super._withdraw(marketIndex, token, amount);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../extensions/ERC20BurnableUpgradeable.sol\";\nimport \"../extensions/ERC20PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\n    function initialize(string memory name, string memory symbol) public virtual initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __ERC20Burnable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IFloatToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\ninterface IFloatToken {\n  function mint(address to, uint256 amount) external;\n\n  function transfer(address, uint256) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function burnFrom(address account, uint256 amount) external virtual;\n}\n"
    },
    "contracts/testing/generated/StakerForInternalMocking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\n\nimport \"./StakerMockable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"../../abstract/AccessControlledAndUpgradeable.sol\";\nimport \"../../interfaces/IFloatToken.sol\";\nimport \"../../interfaces/ILongShort.sol\";\nimport \"../../interfaces/IStaker.sol\";\nimport \"../../interfaces/ISyntheticToken.sol\";\nimport \"../../GEMS.sol\";\nimport \"hardhat/console.sol\";\n\ncontract StakerForInternalMocking {\n  function onlyAdminModifierLogicMock() public pure {\n    return ();\n  }\n\n  function onlyValidSyntheticModifierLogicMock(address) public pure {\n    return ();\n  }\n\n  function onlyLongShortModifierLogicMock() public pure {\n    return ();\n  }\n\n  function _updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShiftsMock(\n    uint32,\n    address\n  ) public pure {\n    return ();\n  }\n\n  function initializeMock(\n    address,\n    address,\n    address,\n    address,\n    address,\n    address,\n    uint256,\n    address\n  ) public pure {\n    return ();\n  }\n\n  function _changeFloatPercentageMock(uint256) public pure {\n    return ();\n  }\n\n  function _changeUnstakeFeeMock(uint32, uint256) public pure {\n    return ();\n  }\n\n  function _changeBalanceIncentiveParametersMock(\n    uint32,\n    uint256,\n    int256,\n    uint256\n  ) public pure {\n    return ();\n  }\n\n  function _getMarketLaunchIncentiveParametersMock(uint32)\n    public\n    pure\n    returns (uint256 period, uint256 multiplier)\n  {\n    return (abi.decode(\"\", (uint256)), abi.decode(\"\", (uint256)));\n  }\n\n  function _getKValueMock(uint32) public pure returns (uint256) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _calculateFloatPerSecondMock(\n    uint32,\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  ) public pure returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    return (abi.decode(\"\", (uint256)), abi.decode(\"\", (uint256)));\n  }\n\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotMock(\n    uint32,\n    uint256\n  ) public pure returns (uint256 timeDelta) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _calculateNewCumulativeIssuancePerStakedSynthMock(\n    uint32,\n    uint256,\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  ) public pure returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    return (abi.decode(\"\", (uint256)), abi.decode(\"\", (uint256)));\n  }\n\n  function _calculateAccumulatedFloatInRangeMock(\n    uint32,\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  ) public pure returns (uint256 floatReward) {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _calculateAccumulatedFloatAndExecuteOutstandingShiftsMock(uint32, address)\n    public\n    pure\n    returns (uint256 floatReward)\n  {\n    return (abi.decode(\"\", (uint256)));\n  }\n\n  function _mintFloatMock(address, uint256) public pure {\n    return ();\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsMock(uint32, address) public pure {\n    return ();\n  }\n\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsMultiMock(uint32[] memory, address)\n    public\n    pure\n  {\n    return ();\n  }\n\n  function stakeFromUserMock(address, uint256) public pure {\n    return ();\n  }\n\n  function shiftTokensMock(\n    uint256,\n    uint32,\n    bool\n  ) public pure {\n    return ();\n  }\n\n  function _withdrawMock(\n    uint32,\n    address,\n    uint256\n  ) public pure {\n    return ();\n  }\n}\n"
    },
    "contracts/testing/StakerInternalStateSetters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"../Staker.sol\";\n\n/*\nNOTE: This contract is for testing purposes only!\n*/\n\ncontract StakerInternalStateSetters is Staker {\n  ///////////////////////////////////////////////\n  //////////// Test Helper Functions ////////////\n  ///////////////////////////////////////////////\n  // TODO: remove parts of this function that aren't necessary for the updated `_calculateAccumulatedFloat` funciton\n  function setFloatRewardCalcParams(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 newLatestRewardIndex,\n    address user,\n    uint256 usersLatestClaimedReward,\n    uint256 accumulativeFloatPerTokenLatestLong,\n    uint256 accumulativeFloatPerTokenLatestShort,\n    uint256 accumulativeFloatPerTokenUserLong,\n    uint256 accumulativeFloatPerTokenUserShort,\n    uint256 newUserAmountStakedLong,\n    uint256 newUserAmountStakedShort\n  ) public {\n    latestRewardIndex[marketIndex] = newLatestRewardIndex;\n    userIndexOfLastClaimedReward[marketIndex][user] = usersLatestClaimedReward;\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newLatestRewardIndex]\n      .accumulativeFloatPerSyntheticToken_long = accumulativeFloatPerTokenLatestLong;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][usersLatestClaimedReward]\n      .accumulativeFloatPerSyntheticToken_long = accumulativeFloatPerTokenUserLong;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newLatestRewardIndex]\n      .accumulativeFloatPerSyntheticToken_short = accumulativeFloatPerTokenLatestShort;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][usersLatestClaimedReward]\n      .accumulativeFloatPerSyntheticToken_short = accumulativeFloatPerTokenUserShort;\n\n    userAmountStaked[longToken][user] = newUserAmountStakedLong;\n    userAmountStaked[shortToken][user] = newUserAmountStakedShort;\n  }\n\n  function setCalculateAccumulatedFloatInRangeGlobals(\n    uint32 marketIndex,\n    uint256 rewardIndexTo,\n    uint256 rewardIndexFrom,\n    uint256 syntheticRewardToLongToken,\n    uint256 syntheticRewardFromLongToken,\n    uint256 syntheticRewardToShortToken,\n    uint256 syntheticRewardFromShortToken\n  ) public {\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long = syntheticRewardToLongToken;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short = syntheticRewardToShortToken;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n      .accumulativeFloatPerSyntheticToken_long = syntheticRewardFromLongToken;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n      .accumulativeFloatPerSyntheticToken_short = syntheticRewardFromShortToken;\n  }\n\n  function setShiftParams(\n    uint32 marketIndex,\n    address user,\n    uint256 shiftAmountLong,\n    uint256 shiftAmountShort,\n    uint256 _userNextPrice_stakedActionIndex,\n    uint256 _latestRewardIndex\n  ) public {\n    userNextPrice_stakedActionIndex[marketIndex][user] = _userNextPrice_stakedActionIndex;\n    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][true][\n      user\n    ] = shiftAmountLong;\n    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][false][\n      user\n    ] = shiftAmountShort;\n\n    latestRewardIndex[marketIndex] = _latestRewardIndex;\n  }\n\n  function setShiftTokensParams(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    address user,\n    uint256 amountSyntheticTokensToShift,\n    uint256 _userAmountStaked,\n    uint256 _userNextPrice_stakedActionIndex,\n    uint256 _latestRewardIndex,\n    address syntheticToken\n  ) public {\n    userNextPrice_stakedActionIndex[marketIndex][user] = _userNextPrice_stakedActionIndex;\n    latestRewardIndex[marketIndex] = _latestRewardIndex;\n\n    if (isShiftFromLong) {\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][true][\n        user\n      ] = amountSyntheticTokensToShift;\n    } else {\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][false][\n        user\n      ] = amountSyntheticTokensToShift;\n    }\n\n    syntheticTokens[marketIndex][isShiftFromLong] = syntheticToken;\n    userAmountStaked[syntheticToken][user] = _userAmountStaked;\n  }\n\n  function setLongShort(address _longShort) public {\n    longShort = _longShort;\n  }\n\n  function setLatestRewardIndexGlobals(uint32 marketIndex, uint256 _latestRewardIndex) external {\n    latestRewardIndex[marketIndex] = _latestRewardIndex;\n  }\n\n  function setGetMarketLaunchIncentiveParametersParams(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 multiplier\n  ) external {\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = multiplier;\n  }\n\n  function setGetKValueParams(uint32 marketIndex, uint256 timestamp) external {\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = timestamp;\n  }\n\n  function setStakeFromUserParams(\n    address longshort,\n    address token,\n    uint32 marketIndexForToken,\n    address user,\n    uint256 _latestRewardIndex,\n    uint256 _userAmountStaked,\n    uint256 userLastRewardIndex\n  ) external {\n    latestRewardIndex[marketIndexForToken] = _latestRewardIndex;\n    userAmountStaked[token][user] = _userAmountStaked;\n    userIndexOfLastClaimedReward[marketIndexForToken][user] = userLastRewardIndex;\n\n    longShort = address(longshort);\n    marketIndexOfToken[token] = marketIndexForToken;\n  }\n\n  function setCalculateTimeDeltaParams(\n    uint32 marketIndex,\n    uint256 latestRewardIndexForMarket,\n    uint256 timestamp\n  ) external {\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndexForMarket]\n      .timestamp = timestamp;\n  }\n\n  function setCalculateNewCumulativeRateParams(\n    uint32 marketIndex,\n    uint256 latestRewardIndexForMarket,\n    uint256 accumFloatLong,\n    uint256 accumFloatShort\n  ) external {\n    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long = accumFloatLong;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short = accumFloatShort;\n  }\n\n  function setSetRewardObjectsParams(uint32 marketIndex, uint256 latestRewardIndexForMarket)\n    external\n  {\n    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;\n  }\n\n  function set_updateStateParams(\n    address _longShort,\n    address token,\n    uint32 tokenMarketIndex\n  ) public {\n    longShort = _longShort;\n    marketIndexOfToken[token] = tokenMarketIndex;\n  }\n\n  function set_mintFloatParams(address _floatToken, uint16 _floatPercentage) public {\n    floatToken = _floatToken;\n    floatPercentage = _floatPercentage;\n  }\n\n  function setMintAccumulatedFloatAndClaimFloatParams(\n    uint32 marketIndex,\n    uint256 latestRewardIndexForMarket\n  ) public {\n    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;\n  }\n\n  function set_withdrawGlobals(\n    uint32 marketIndex,\n    address syntheticToken,\n    address user,\n    uint256 amountStaked,\n    uint256 fees,\n    address treasury\n  ) external {\n    marketIndexOfToken[syntheticToken] = marketIndex;\n    marketUnstakeFee_e18[marketIndex] = fees;\n    userAmountStaked[syntheticToken][user] = amountStaked;\n    floatTreasury = treasury;\n  }\n\n  function setWithdrawGlobals(\n    uint32 marketIndex,\n    address _longShort,\n    address token\n  ) external {\n    marketIndexOfToken[token] = marketIndex;\n    longShort = _longShort;\n  }\n\n  function setWithdrawAllGlobals(\n    uint32 marketIndex,\n    address _longShort,\n    address user,\n    uint256 amountStaked,\n    address token,\n    uint256 _userNextPrice_stakedActionIndex,\n    address _syntheticTokens,\n    uint256 _userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long,\n    uint256 _userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short\n  ) external {\n    marketIndexOfToken[token] = marketIndex;\n    longShort = _longShort;\n    userAmountStaked[token][user] = amountStaked;\n    userNextPrice_stakedActionIndex[marketIndex][user] = _userNextPrice_stakedActionIndex;\n    syntheticTokens[marketIndex][true] = _syntheticTokens;\n    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][true][\n      user\n    ] = _userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][false][\n      user\n    ] = _userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n  }\n\n  function setEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n  {\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  ///////////////////////////////////////////////////////\n  //////////// Functions for Experimentation ////////////\n  ///////////////////////////////////////////////////////\n\n  function getRequiredAmountOfBitShiftForSafeExponentiationPerfect(uint256 number, uint256 exponent)\n    external\n    pure\n    returns (uint256 amountOfBitShiftRequired)\n  {\n    uint256 targetMaxNumberSizeBinaryDigits = 257 / exponent;\n\n    // Note this can be optimised, this gets a quick easy to compute safe upper bound, not the actuall upper bound.\n    uint256 targetMaxNumber = 2**targetMaxNumberSizeBinaryDigits;\n\n    while (number >> amountOfBitShiftRequired > targetMaxNumber) {\n      ++amountOfBitShiftRequired;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Staker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./GEMS.sol\";\n\ncontract Staker is IStaker, AccessControlledAndUpgradeable {\n  /*╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝*/\n\n  bytes32 public constant DISCOUNT_ROLE = keccak256(\"DISCOUNT_ROLE\");\n\n  /* ══════ Fixed-precision constants ══════ */\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 3e44;\n\n  /* ══════ Global state ══════ */\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  address public gems;\n  uint256[45] private __globalStateGap;\n\n  /* ══════ Market specific ══════ */\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n  mapping(uint32 => uint256) public safeExponentBitShifting;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n  uint256[45] private __marketStateGap;\n\n  mapping(address => uint32) public marketIndexOfToken;\n  mapping(address => uint32) public userNonce;\n  uint256[45] private __synthStateGap;\n\n  /* ══════ Reward specific ══════ */\n  mapping(uint32 => uint256) public latestRewardIndex; // This is synced to be the same as LongShort\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  uint256[45] private __rewardStateGap;\n  /* ══════ User specific ══════ */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public override userAmountStaked;\n  uint256[45] private __userStateGap;\n\n  /* ══════ Next price action management specific ══════ */\n  /// @dev marketIndex => usersAddress => stakedActionIndex\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedActionIndex;\n\n  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom;\n\n  /// @dev marketIndex => usersAddress => stakedActionIndex\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_paymentToken_depositAmount;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function onlyAdminModifierLogic() internal virtual {\n    _checkRole(ADMIN_ROLE, msg.sender);\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not LongShort\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n\n  function _updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n    uint32 marketIndex,\n    address user\n  ) internal virtual {\n    if (\n      userNextPrice_stakedActionIndex[marketIndex][msg.sender] != 0 &&\n      userNextPrice_stakedActionIndex[marketIndex][msg.sender] <= latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, msg.sender);\n    }\n  }\n\n  modifier updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n    uint32 marketIndex,\n    address user\n  ) {\n    _updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n    _;\n  }\n\n  modifier gemCollecting(address user) {\n    GEMS(gems).gm(user);\n    _;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /**\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin's initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  */\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    address _discountSigner,\n    uint256 _floatPercentage,\n    address _gems\n  ) external virtual initializer {\n    require(\n      _admin != address(0) &&\n        _longShort != address(0) &&\n        _floatToken != address(0) &&\n        _floatTreasury != address(0) &&\n        _floatCapital != address(0) &&\n        _gems != address(0) &&\n        _floatPercentage != 0\n    );\n\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n    gems = _gems;\n\n    _AccessControlledAndUpgradeable_init(_admin);\n    _setupRole(DISCOUNT_ROLE, _discountSigner);\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /*╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /**\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitly stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /**\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18)\n    external\n    onlyAdmin\n  {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveParameters(\n    uint32 marketIndex,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset,\n    uint256 _safeExponentBitShifting\n  ) internal virtual {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 &&\n        _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n    require(_balanceIncentiveCurve_exponent > 0, \"balanceIncentiveCurve_exponent out of bounds\");\n    require(_safeExponentBitShifting < 100, \"safeExponentBitShifting out of bounds\");\n\n    uint256 totalLocked = ILongShort(longShort).marketSideValueInPaymentToken(marketIndex, true) +\n      ILongShort(longShort).marketSideValueInPaymentToken(marketIndex, false);\n\n    // SafeMATH will revert here if this value is too big.\n    (((totalLocked * 500) >> _safeExponentBitShifting)**_balanceIncentiveCurve_exponent);\n    // Required to ensure at least 3 digits of precision.\n    require(\n      totalLocked >> _safeExponentBitShifting > 100,\n      \"bit shifting too lange for total locked\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n    safeExponentBitShifting[marketIndex] = _safeExponentBitShifting;\n  }\n\n  /**\n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  @param _safeExponentBitShifting The new bitshifting applied to the curve.\n  */\n  function changeBalanceIncentiveParameters(\n    uint32 marketIndex,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset,\n    uint256 _safeExponentBitShifting\n  ) external onlyAdmin {\n    _changeBalanceIncentiveParameters(\n      marketIndex,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset,\n      _safeExponentBitShifting\n    );\n\n    emit BalanceIncentiveParamsUpdated(\n      marketIndex,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset,\n      _safeExponentBitShifting\n    );\n  }\n\n  /*╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝*/\n\n  /**\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  */\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    require(kInitialMultiplier >= 1e18, \"kInitialMultiplier must be >= 1e18\");\n\n    // a safe initial default value\n    uint256 initialSafeExponentBitShifting = 50;\n\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n    _changeBalanceIncentiveParameters(\n      marketIndex,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset,\n      initialSafeExponentBitShifting\n    );\n\n    marketLaunchIncentive_period[marketIndex] = kPeriod;\n    marketLaunchIncentive_multipliers[marketIndex] = kInitialMultiplier;\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset,\n      initialSafeExponentBitShifting\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /*╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝*/\n\n  /**\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven't been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex]; // seconds TODO change name to contain seconds\n    multiplier = marketLaunchIncentive_multipliers[marketIndex]; // 1e18 TODO change name to contain E18\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  /**\n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market's launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  */\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(\n      marketIndex\n    );\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0]\n      .timestamp;\n\n    if (block.timestamp - initialTimestamp < kPeriod) {\n      return\n        kInitialMultiplier -\n        (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /*\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they've staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see:\n  https://ipfs.io/ipfs/QmRWbr8P1F588XqRTzm7wCsRPu8DcDVPWGriBach4f22Fq/staker-fps.pdf\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   */\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 safetyBitShifting = safeExponentBitShifting[marketIndex];\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - (2 * equilibriumOffsetMarketScaled) < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremely unlikely to happen in practice\n        return (0, k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safetyBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      uint256 denominator = ((totalLocked >> safetyBitShifting) **\n        balanceIncentiveCurve_exponent[marketIndex]);\n\n      // NOTE: `x * 5e17` == `(x * 1e18) / 2`\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return (\n        (longRewardUnscaled * k * longPrice) / 1e18,\n        (shortRewardUnscaled * k * shortPrice) / 1e18\n      );\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremely unlikely to happen in practice\n        return (k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safetyBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      uint256 denominator = ((totalLocked >> safetyBitShifting) **\n        balanceIncentiveCurve_exponent[marketIndex]);\n\n      // NOTE: `x * 5e17` == `(x * 1e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return (\n        (longRewardUnscaled * k * longPrice) / 1e18,\n        (shortRewardUnscaled * k * shortPrice) / 1e18\n      );\n    }\n  }\n\n  /**\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return timeDelta The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex\n  ) internal view virtual returns (uint256 timeDelta) {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][previousMarketUpdateIndex].timestamp;\n  }\n\n  /**\n  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative 'r' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  */\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 previousMarketUpdateIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(\n      marketIndex,\n      previousMarketUpdateIndex\n    );\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][previousMarketUpdateIndex]\n        .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][previousMarketUpdateIndex]\n        .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /**\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param marketIndex An identifier for the market.\n  @param marketUpdateIndex Current update index in the LongShort contract for this market.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  */\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 marketUpdateIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) external override onlyLongShort {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(\n        marketIndex,\n        marketUpdateIndex - 1,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n\n    AccumulativeIssuancePerStakedSynthSnapshot\n      storage accumulativeFloatPerSyntheticTokenSnapshot = accumulativeFloatPerSyntheticTokenSnapshots[\n        marketIndex\n      ][marketUpdateIndex];\n    accumulativeFloatPerSyntheticTokenSnapshot\n      .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshot\n      .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshot.timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = marketUpdateIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      marketUpdateIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /*╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝*/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][\n        rewardIndexTo\n      ].accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n          .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][\n        rewardIndexTo\n      ].accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n          .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  /**\n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   */\n  function _calculateAccumulatedFloatAndExecuteOutstandingShifts(uint32 marketIndex, address user)\n    internal\n    virtual\n    returns (uint256 floatReward)\n  {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    uint256 currentRewardIndex = latestRewardIndex[marketIndex];\n\n    // Don't do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == currentRewardIndex) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedActionIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex <= currentRewardIndex) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        usersShiftIndex\n      );\n\n      // Update the users balances\n\n      uint256 amountToShiftAwayFromCurrentSide = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[\n          marketIndex\n        ][true][user];\n      // Handle shifts from LONG side:\n      if (amountToShiftAwayFromCurrentSide > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          amountToShiftAwayFromCurrentSide,\n          true,\n          usersShiftIndex\n        );\n\n        amountStakedLong -= amountToShiftAwayFromCurrentSide;\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][true][user] = 0;\n      }\n\n      amountToShiftAwayFromCurrentSide = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[\n        marketIndex\n      ][false][user];\n      // Handle shifts from SHORT side:\n      if (amountToShiftAwayFromCurrentSide > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          amountToShiftAwayFromCurrentSide,\n          false,\n          usersShiftIndex\n        );\n\n        amountStakedShort -= amountToShiftAwayFromCurrentSide;\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][false][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      emit StakeShifted(user, marketIndex, amountStakedLong, amountStakedShort);\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersShiftIndex,\n        currentRewardIndex\n      );\n\n      userNextPrice_stakedActionIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        currentRewardIndex\n      );\n    }\n  }\n\n  /**\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /**\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloatAndExecuteOutstandingShifts(uint32 marketIndex, address user)\n    internal\n    virtual\n  {\n    uint256 floatToMint = _calculateAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /**\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(\n    uint32[] calldata marketIndexes,\n    address user\n  ) internal virtual {\n    uint256 floatTotal = 0;\n    uint256 length = marketIndexes.length;\n    for (uint256 i = 0; i < length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloatAndExecuteOutstandingShifts(\n        marketIndexes[i],\n        user\n      );\n\n      if (floatToMint > 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal > 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /**\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(marketIndexes, msg.sender);\n  }\n\n  /**\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   */\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatAndExecuteOutstandingShiftsMulti(marketIndexes, user);\n  }\n\n  /*╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝*/\n\n  /**\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  */\n  function stakeFromUser(address from, uint256 amount)\n    external\n    virtual\n    override\n    onlyValidSynthetic(msg.sender)\n    gemCollecting(from)\n  {\n    uint32 marketIndex = marketIndexOfToken[msg.sender];\n    ILongShort(longShort).updateSystemState(marketIndex);\n\n    uint256 userCurrentIndexOfLastClaimedReward = userIndexOfLastClaimedReward[marketIndex][from];\n    uint256 currentRewardIndex = latestRewardIndex[marketIndex];\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userCurrentIndexOfLastClaimedReward != 0 &&\n      userCurrentIndexOfLastClaimedReward < currentRewardIndex\n    ) {\n      _mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, from);\n    }\n\n    userAmountStaked[msg.sender][from] += amount;\n\n    // NOTE: Users retroactively earn a little bit of FLT because they start earning from the previous update index.\n    userIndexOfLastClaimedReward[marketIndex][from] = currentRewardIndex;\n\n    emit StakeAdded(from, msg.sender, amount, currentRewardIndex);\n  }\n\n  /**\n  @notice Allows users to shift their staked tokens from one side of the market to\n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  */\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  )\n    external\n    virtual\n    override\n    updateUsersStakedPosition_mintAccumulatedFloatAndExecuteOutstandingShifts(\n      marketIndex,\n      msg.sender\n    )\n    gemCollecting(msg.sender)\n  {\n    require(amountSyntheticTokensToShift > 0, \"No zero shifts.\");\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    uint256 totalAmountForNextShift = amountSyntheticTokensToShift +\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][isShiftFromLong][\n        msg.sender\n      ];\n\n    require(\n      userAmountStaked[token][msg.sender] >= totalAmountForNextShift,\n      \"Not enough tokens to shift\"\n    );\n\n    ILongShort(longShort).shiftPositionNextPrice(\n      marketIndex,\n      amountSyntheticTokensToShift,\n      isShiftFromLong\n    );\n\n    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[marketIndex][isShiftFromLong][\n      msg.sender\n    ] = totalAmountForNextShift;\n\n    uint256 userRewardIndex = latestRewardIndex[marketIndex] + 1;\n    userNextPrice_stakedActionIndex[marketIndex][msg.sender] = userRewardIndex;\n\n    emit NextPriceStakeShift(\n      msg.sender,\n      marketIndex,\n      amountSyntheticTokensToShift,\n      isShiftFromLong,\n      userRewardIndex\n    );\n  }\n\n  /*╔════════════════════════════╗\n    ║    WITHDRAWAL & MINTING    ║\n    ╚════════════════════════════╝*/\n\n  /**\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  */\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual gemCollecting(msg.sender) {\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    ISyntheticToken(token).transfer(floatTreasury, amountFees);\n    ISyntheticToken(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  function _withdrawPrepLogic(\n    uint32 marketIndex,\n    bool isWithdrawFromLong,\n    uint256 amount,\n    address token\n  ) internal {\n    ILongShort(longShort).updateSystemState(marketIndex);\n    _mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, msg.sender);\n\n    uint256 currentAmountStaked = userAmountStaked[token][msg.sender];\n    // If this value is greater than zero they have pending nextPriceShifts; don't allow user to shit these reserved tokens.\n    uint256 amountToShiftForThisToken = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[\n      marketIndex\n    ][isWithdrawFromLong][msg.sender];\n\n    unchecked {\n      require(currentAmountStaked >= amount + amountToShiftForThisToken, \"not enough to withdraw\");\n      userAmountStaked[token][msg.sender] = currentAmountStaked - amount;\n    }\n  }\n\n  /**\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param marketIndex Market index of staked synthetic token\n  @param isWithdrawFromLong is synthetic token to be withdrawn long or short\n  */\n  function withdraw(\n    uint32 marketIndex,\n    bool isWithdrawFromLong,\n    uint256 amount\n  ) external {\n    address token = syntheticTokens[marketIndex][isWithdrawFromLong];\n    _withdrawPrepLogic(marketIndex, isWithdrawFromLong, amount, token);\n    _withdraw(marketIndex, token, amount);\n  }\n\n  /**\n  @notice Allows users to withdraw their entire stake for a token.\n  @param marketIndex Market index of staked synthetic token\n  @param isWithdrawFromLong is synthetic token to be withdrawn long or short\n  */\n  function withdrawAll(uint32 marketIndex, bool isWithdrawFromLong) external {\n    ILongShort(longShort).updateSystemState(marketIndex);\n    _mintAccumulatedFloatAndExecuteOutstandingShifts(marketIndex, msg.sender);\n\n    address token = syntheticTokens[marketIndex][isWithdrawFromLong];\n\n    uint256 userAmountStakedBeforeWithdrawal = userAmountStaked[token][msg.sender];\n\n    uint256 amountToShiftForThisToken = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom[\n      marketIndex\n    ][isWithdrawFromLong][msg.sender];\n    userAmountStaked[token][msg.sender] = amountToShiftForThisToken;\n\n    _withdraw(marketIndex, token, userAmountStakedBeforeWithdrawal - amountToShiftForThisToken);\n  }\n\n  function _hasher(\n    uint32 marketIndex,\n    bool isWithdrawFromLong,\n    address user,\n    uint256 withdrawAmount,\n    uint256 expiry,\n    uint256 nonce,\n    uint256 discountWithdrawFee\n  ) internal pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encodePacked(\n          \"\\x19Ethereum Signed Message:\\n32\",\n          keccak256(\n            abi.encodePacked(\n              marketIndex,\n              isWithdrawFromLong,\n              user,\n              withdrawAmount,\n              expiry,\n              nonce,\n              discountWithdrawFee\n            )\n          )\n        )\n      );\n  }\n\n  function withdrawWithVoucher(\n    uint32 marketIndex,\n    bool isWithdrawFromLong,\n    uint256 withdrawAmount,\n    uint256 expiry,\n    uint256 nonce,\n    uint256 discountWithdrawFee,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external gemCollecting(msg.sender) {\n    address discountSigner = ecrecover(\n      _hasher(\n        marketIndex,\n        isWithdrawFromLong,\n        msg.sender,\n        withdrawAmount,\n        expiry,\n        nonce,\n        discountWithdrawFee\n      ),\n      v,\n      r,\n      s\n    );\n    hasRole(DISCOUNT_ROLE, discountSigner);\n\n    require(block.timestamp < expiry, \"coupon expired\");\n    require(userNonce[msg.sender] == nonce, \"invalid nonce\");\n    require(discountWithdrawFee < marketUnstakeFee_e18[marketIndex], \"bad discount fee\");\n    userNonce[msg.sender] = userNonce[msg.sender] + 1;\n\n    address token = syntheticTokens[marketIndex][isWithdrawFromLong];\n\n    _withdrawPrepLogic(marketIndex, isWithdrawFromLong, withdrawAmount, token);\n\n    uint256 amountFees = (withdrawAmount * discountWithdrawFee) / 1e18;\n    ISyntheticToken(token).transfer(floatTreasury, amountFees);\n    ISyntheticToken(token).transfer(msg.sender, withdrawAmount - amountFees);\n    emit StakeWithdrawn(msg.sender, token, withdrawAmount);\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerFlippening_V0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracleManager.sol\";\n\n/**\n  Contract that estimates ETH / BTC dominance,\n  expressed as (eth market cap) / (btc market cap)\n  Estimates BTC & ETH supply. In the future\n  look towards using oracles for it. \n*/\ncontract OracleManagerFlippening_V0 is IOracleManager {\n  address public admin; // This will likely be the Gnosis safe\n\n  int256 public ethDominance;\n\n  uint256 public ethSupply; // 18 decimals\n  uint256 public btcSupply; // 8 decimals\n\n  uint256 public btcBlocksPerDay;\n  uint256 public ethBlocksPerDay;\n\n  uint256 public btcBlockReward; // 8 decimals\n  uint256 public ethBlockReward; // 18 decimals\n\n  uint256 public ethUnclesPerDay;\n\n  // Eth has a variable uncle reward:\n  //       - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1234.md,\n  // Source here says it's roughly 75%:\n  //       - https://docs.ethhub.io/ethereum-basics/monetary-policy/\n  // Might be worth also looking into just taking it as the mean of the possibilities\n  //         = sum from 1 to 7 of (8 - sumIndex) * blockReward / 8 / 7\n\n  uint256 public ethUncleReward; // 18 decimals\n\n  uint256 public ethNephewReward; // 18 decimals. currently = blockReward / 32\n\n  uint256 lastUpdated;\n\n  // Oracle addresses\n  AggregatorV3Interface public btcOracle;\n  AggregatorV3Interface public ethOracle;\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin);\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  constructor(\n    address _admin,\n    address _btcOracle,\n    address _ethOracle,\n    uint256 _ethSupply,\n    uint256 _btcSupply,\n    uint256 _btcBlocksPerDay,\n    uint256 _ethBlocksPerDay,\n    uint256 _ethUnclesPerDay,\n    uint256 _btcBlockReward,\n    uint256 _ethBlockReward,\n    uint256 _ethUncleReward,\n    uint256 _ethNephewReward\n  ) {\n    admin = _admin;\n\n    btcOracle = AggregatorV3Interface(_btcOracle);\n    ethOracle = AggregatorV3Interface(_ethOracle);\n\n    ethSupply = _ethSupply;\n    btcSupply = _btcSupply;\n\n    btcBlocksPerDay = _btcBlocksPerDay;\n\n    ethBlocksPerDay = _ethBlocksPerDay;\n    ethUnclesPerDay = _ethUnclesPerDay;\n\n    btcBlockReward = _btcBlockReward;\n\n    ethBlockReward = _ethBlockReward;\n    ethUncleReward = _ethUncleReward;\n    ethNephewReward = _ethNephewReward;\n\n    lastUpdated = block.timestamp;\n\n    _updatePrice();\n  }\n\n  ////////////////////////////////////\n  /// MULTISIG ADMIN FUNCTIONS ///////\n  ////////////////////////////////////\n\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  function changeEthSupply(uint256 supply) external adminOnly {\n    ethSupply = supply;\n  }\n\n  function changeBtcSupply(uint256 supply) external adminOnly {\n    btcSupply = supply;\n  }\n\n  function changeBtcBlocksPerDay(uint256 blocks) external adminOnly {\n    btcBlocksPerDay = blocks;\n  }\n\n  function changeEthBlocksPerDay(uint256 blocks) external adminOnly {\n    ethBlocksPerDay = blocks;\n  }\n\n  function changeEthUnclesPerDay(uint256 uncles) external adminOnly {\n    ethUnclesPerDay = uncles;\n  }\n\n  function changeBtcBlockReward(uint256 reward) external adminOnly {\n    btcBlockReward = reward;\n  }\n\n  function changeEthBlockReward(uint256 reward) external adminOnly {\n    ethBlockReward = reward;\n  }\n\n  function changeEthUncleReward(uint256 reward) external adminOnly {\n    ethUncleReward = reward;\n  }\n\n  function changeEthNephewReward(uint256 reward) external adminOnly {\n    ethNephewReward = reward;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  function _getBtcSupply() internal view returns (uint256) {\n    return\n      btcSupply + (((block.timestamp - lastUpdated) * btcBlocksPerDay * btcBlockReward) / (1 days));\n  }\n\n  function _getEthSupply() internal view returns (uint256) {\n    return\n      ethSupply +\n      (((block.timestamp - lastUpdated) *\n        (ethBlocksPerDay * ethBlockReward + ethUnclesPerDay * (ethNephewReward + ethUncleReward))) /\n        1 days);\n  }\n\n  function _updatePrice() private returns (int256) {\n    (, int256 _ethPrice, , , ) = ethOracle.latestRoundData();\n    (, int256 _btcPrice, , , ) = btcOracle.latestRoundData();\n    ethSupply = _getEthSupply();\n    btcSupply = _getBtcSupply();\n\n    lastUpdated = block.timestamp;\n\n    // ethSupply * ethPrice = 26 decimals\n    // btcSupply * btcPrice = 16 decimals\n\n    // 1e20 as 18 decimals but as %\n    ethDominance = int256(\n      (uint256(_ethPrice) * ethSupply * 1e20) / (uint256(_btcPrice) * btcSupply * 1e10)\n    );\n\n    return ethDominance;\n  }\n\n  function updatePrice() external override returns (int256) {\n    return _updatePrice();\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return ethDominance;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/oracles/OracleManagerFlipp3ning.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/IOracleManager.sol\";\n\ncontract OracleManagerFlipp3ning is IOracleManager {\n  address public ethMarketCapFeed;\n  address public btcMarketCapFeed;\n\n  struct PriceData {\n    uint80 lastRoundEth;\n    uint80 lastRoundBtc;\n    uint128 price;\n  }\n\n  PriceData public priceData;\n\n  constructor(address _ethMarketCapFeed, address _btcMarketCapFeed) {\n    ethMarketCapFeed = _ethMarketCapFeed;\n    btcMarketCapFeed = _btcMarketCapFeed;\n\n    require(\n      AggregatorV3Interface(ethMarketCapFeed).decimals() ==\n        AggregatorV3Interface(btcMarketCapFeed).decimals(),\n      \"Decimals for feeds are different!\"\n    );\n\n    (uint80 _ethRound, uint80 _btcRound, int256 _ethMarketCap, int256 _btcMarketCap) = _feedData();\n\n    priceData.price = _dominance(_ethMarketCap, _btcMarketCap);\n    priceData.lastRoundEth = _ethRound;\n    priceData.lastRoundBtc = _btcRound;\n  }\n\n  function _feedData()\n    internal\n    view\n    returns (\n      uint80 ethRound,\n      uint80 btcRound,\n      int256 ethPrice,\n      int256 btcPrice\n    )\n  {\n    (ethRound, ethPrice, , , ) = AggregatorV3Interface(ethMarketCapFeed).latestRoundData();\n    (btcRound, btcPrice, , , ) = AggregatorV3Interface(btcMarketCapFeed).latestRoundData();\n  }\n\n  function _dominance(int256 _ethMarketCap, int256 _btcMarketCap) internal view returns (uint128) {\n    // reverts if btc market cap == 0\n    return uint128(uint256((_ethMarketCap * 1e20) / _btcMarketCap));\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return int256(uint256(priceData.price));\n  }\n\n  function updatePrice() external override returns (int256) {\n    (uint80 _ethRound, uint80 _btcRound, int256 _ethMarketCap, int256 _btcMarketCap) = _feedData();\n\n    if (_ethRound == priceData.lastRoundEth || _btcRound == priceData.lastRoundBtc) {\n      return int256(uint256(priceData.price));\n    }\n\n    uint128 price = _dominance(_ethMarketCap, _btcMarketCap);\n    priceData.price = price;\n    priceData.lastRoundEth = _ethRound;\n    priceData.lastRoundBtc = _btcRound;\n\n    return int256(uint256(price));\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerEthVsBtc.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracleManager.sol\";\n\n/**\n  Contract that gives price ration of ETH/BTC\n*/\ncontract OracleManagerEthVsBtc is IOracleManager {\n  address public admin; // This will likely be the Gnosis safe\n\n  int256 public ethDominance;\n\n  // Oracle addresses\n  AggregatorV3Interface public btcOracle;\n  AggregatorV3Interface public ethOracle;\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin);\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  constructor(\n    address _admin,\n    address _btcOracle,\n    address _ethOracle\n  ) {\n    admin = _admin;\n\n    btcOracle = AggregatorV3Interface(_btcOracle);\n    ethOracle = AggregatorV3Interface(_ethOracle);\n\n    _updatePrice();\n  }\n\n  ////////////////////////////////////\n  /// MULTISIG ADMIN FUNCTIONS ///////\n  ////////////////////////////////////\n\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  function _updatePrice() private returns (int256) {\n    (, int256 _ethPrice, , , ) = ethOracle.latestRoundData();\n    (, int256 _btcPrice, , , ) = btcOracle.latestRoundData();\n\n    // 1e20 as 18 decimals but as %\n    ethDominance = int256((uint256(_ethPrice) * 1e20) / (uint256(_btcPrice)));\n\n    return ethDominance;\n  }\n\n  function updatePrice() external override returns (int256) {\n    return _updatePrice();\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return ethDominance;\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerEthKillerChainlink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracleManager.sol\";\n\ncontract OracleManagerEthKillerChainlink is IOracleManager {\n  address public admin; // This will likely be the Gnosis safe\n\n  // Oracle price, changes by average of the underlying asset changes.\n  int256 public indexPrice;\n\n  // Underlying asset prices.\n  int256 public tronPrice;\n  int256 public eosPrice;\n  int256 public xrpPrice;\n\n  // Oracle addresses\n  AggregatorV3Interface public tronOracle;\n  AggregatorV3Interface public eosOracle;\n  AggregatorV3Interface public xrpOracle;\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin);\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  constructor(\n    address _admin,\n    address _tronOracle,\n    address _eosOracle,\n    address _xrpOracle\n  ) {\n    admin = _admin;\n    tronOracle = AggregatorV3Interface(_tronOracle);\n    eosOracle = AggregatorV3Interface(_eosOracle);\n    xrpOracle = AggregatorV3Interface(_xrpOracle);\n    // Initial asset prices.\n    (tronPrice, eosPrice, xrpPrice) = _getAssetPrices();\n\n    // Initial base index price.\n    indexPrice = 1e18;\n  }\n\n  ////////////////////////////////////\n  /// MULTISIG ADMIN FUNCTIONS ///////\n  ////////////////////////////////////\n\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  function _getAssetPrices()\n    internal\n    view\n    returns (\n      int256,\n      int256,\n      int256\n    )\n  {\n    (, int256 _tronPrice, , , ) = tronOracle.latestRoundData();\n    (, int256 _eosPrice, , , ) = eosOracle.latestRoundData();\n    (, int256 _xrpPrice, , , ) = xrpOracle.latestRoundData();\n    return (_tronPrice, _eosPrice, _xrpPrice);\n  }\n\n  function _updatePrice() internal virtual returns (int256) {\n    (int256 newTronPrice, int256 newEosPrice, int256 newXrpPrice) = _getAssetPrices();\n\n    int256 valueOfChangeInIndex = (int256(indexPrice) *\n      (_calcAbsolutePercentageChange(newTronPrice, tronPrice) +\n        _calcAbsolutePercentageChange(newEosPrice, eosPrice) +\n        _calcAbsolutePercentageChange(newXrpPrice, xrpPrice))) / (3 * 1e18);\n\n    tronPrice = newTronPrice;\n    eosPrice = newEosPrice;\n    xrpPrice = newXrpPrice;\n\n    indexPrice = indexPrice + valueOfChangeInIndex;\n\n    return indexPrice;\n  }\n\n  function updatePrice() external override returns (int256) {\n    return _updatePrice();\n  }\n\n  function _calcAbsolutePercentageChange(int256 newPrice, int256 basePrice)\n    internal\n    pure\n    returns (int256)\n  {\n    return ((newPrice - basePrice) * (1e18)) / (basePrice);\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return indexPrice;\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerEthKillerChainlinkTestnet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./OracleManagerEthKillerChainlink.sol\";\n\ncontract OracleManagerEthKillerChainlinkTestnet is OracleManagerEthKillerChainlink {\n  uint256 lastUpdate;\n  uint256 maxUpdateIntervalSeconds;\n  int256 forcedPriceAdjustment;\n\n  constructor(\n    address _admin,\n    address _tronOracle,\n    address _eosOracle,\n    address _xrpOracle,\n    uint256 _maxUpdateIntervalSeconds\n  ) OracleManagerEthKillerChainlink(_admin, _tronOracle, _eosOracle, _xrpOracle) {\n    maxUpdateIntervalSeconds = _maxUpdateIntervalSeconds;\n  }\n\n  function setMaxUpdateInterval(uint256 newMaxUpdateIntervalSeconds) external adminOnly {\n    maxUpdateIntervalSeconds = newMaxUpdateIntervalSeconds;\n  }\n\n  function _updatePrice() internal override returns (int256) {\n    int256 previousPrice = indexPrice;\n    int256 latestPrice = super._updatePrice();\n\n    if (previousPrice != latestPrice || lastUpdate + maxUpdateIntervalSeconds < block.timestamp) {\n      forcedPriceAdjustment = (forcedPriceAdjustment + 1) % 2;\n      lastUpdate = block.timestamp;\n    }\n\n    return latestPrice + forcedPriceAdjustment;\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerChainlink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"../interfaces/IOracleManager.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/*\n * Implementation of an OracleManager that fetches prices from a Chainlink aggregate price feed.\n */\ncontract OracleManagerChainlink is IOracleManager {\n  // Admin addresses.\n  address public admin;\n  // Global state.\n  AggregatorV3Interface public chainlinkOracle;\n  uint8 public oracleDecimals;\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin, \"Not admin\");\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n  constructor(address _admin, address _chainlinkOracle) {\n    admin = _admin;\n    chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);\n    oracleDecimals = chainlinkOracle.decimals();\n  }\n\n  ////////////////////////////////////\n  /// MULTISIG ADMIN FUNCTIONS ///////\n  ////////////////////////////////////\n\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n  function _getLatestPrice() internal view returns (int256) {\n    (, int256 price, , , ) = chainlinkOracle.latestRoundData();\n    return price;\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return _getLatestPrice();\n  }\n\n  function updatePrice() external virtual override returns (int256) {\n    return _getLatestPrice();\n  }\n}\n"
    },
    "contracts/oracles/OracleManagerChainlinkTestnet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./OracleManagerChainlink.sol\";\n\ncontract OracleManagerChainlinkTestnet is OracleManagerChainlink {\n  uint256 lastUpdate;\n  uint256 maxUpdateIntervalSeconds;\n  int256 forcedPriceAdjustment;\n\n  constructor(\n    address _admin,\n    address _chainlinkOracle,\n    uint256 _maxUpdateIntervalSeconds\n  ) OracleManagerChainlink(_admin, _chainlinkOracle) {\n    maxUpdateIntervalSeconds = _maxUpdateIntervalSeconds;\n  }\n\n  function setMaxUpdateInterval(uint256 newMaxUpdateIntervalSeconds) external adminOnly {\n    maxUpdateIntervalSeconds = newMaxUpdateIntervalSeconds;\n  }\n\n  function updatePrice() external override returns (int256) {\n    int256 latestPrice = super._getLatestPrice();\n\n    int256 priceAdjustment = forcedPriceAdjustment;\n    if (lastUpdate + maxUpdateIntervalSeconds < block.timestamp) {\n      priceAdjustment = (priceAdjustment + 1) % 2;\n      forcedPriceAdjustment = priceAdjustment;\n      lastUpdate = block.timestamp;\n    }\n\n    return latestPrice + priceAdjustment;\n  }\n}\n"
    },
    "contracts/mocks/AggregatorV3Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/*\n * AggregatorV3Mock is an implementation of a chainlink oracle that allows prices\n * to be set arbitrarily for testing.\n */\ncontract AggregatorV3Mock is AggregatorV3Interface, Initializable {\n  // Admin contracts.\n  address public admin;\n  uint8 public override decimals;\n  uint256 public override version;\n\n  string public override description = \"This is a mock chainlink oracle\";\n\n  struct RoundData {\n    uint80 answeredInRound;\n    int256 answer;\n    uint256 setAt;\n  }\n  mapping(uint80 => RoundData) public roundData;\n  uint80 currentRoundId;\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin, \"Not admin\");\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  function setup(\n    address _admin,\n    int256 _price,\n    uint8 _decimals\n  ) public initializer {\n    admin = _admin;\n    decimals = (_decimals != 0) ? _decimals : 18;\n    version = 1;\n    currentRoundId = 1;\n    roundData[currentRoundId] = RoundData(currentRoundId, _price, block.timestamp);\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  /*\n   * Sets the mock rate for the oracle.\n   */\n  function setPrice(int256 _price) public {\n    currentRoundId = currentRoundId + 1;\n    roundData[currentRoundId] = RoundData(currentRoundId, _price, block.timestamp);\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    RoundData storage round = roundData[_roundId];\n    return (_roundId, round.answer, round.setAt, round.setAt, 1);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    RoundData storage round = roundData[currentRoundId];\n    return (currentRoundId, round.answer, round.setAt, round.setAt, 1);\n  }\n}\n"
    },
    "contracts/SyntheticTokenUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n@title SyntheticTokenUpgradeable\n@notice An ERC20 token that tracks or inversely tracks the price of an\n        underlying asset with floating exposure.\n@dev Logic for price tracking contained in LongShort.sol. \n     The contract inherits from ERC20PresetMinterPauser.sol\n*/\ncontract SyntheticTokenUpgradeable is\n  ISyntheticToken,\n  Initializable,\n  ERC20Upgradeable,\n  ERC20BurnableUpgradeable,\n  AccessControlUpgradeable,\n  ERC20PermitUpgradeable,\n  UUPSUpgradeable\n{\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n  /// @notice Address of the LongShort contract, a deployed LongShort.sol\n  address public longShort;\n  /// @notice Address of the Staker contract, a deployed Staker.sol\n  address public staker;\n  /// @notice Identifies which market in longShort the token is for.\n  uint32 public marketIndex;\n  /// @notice Whether the token is a long token or short token for its market.\n  bool public isLong;\n\n  /// @notice Creates an instance of the contract.\n  /// @dev Should only be called by TokenFactory.sol for our system.\n  /// @param name The name of the token.\n  /// @param symbol The symbol for the token.\n  /// @param _longShort Address of the core LongShort contract.\n  /// @param _staker Address of the staker contract.\n  /// @param _marketIndex Which market the token is for.\n  /// @param _isLong Whether the token is long or short for its market.\n  function initialize(\n    string memory name,\n    string memory symbol,\n    address _longShort,\n    address _staker,\n    uint32 _marketIndex,\n    bool _isLong\n  ) external initializer {\n    __ERC20_init(name, symbol);\n    __ERC20Burnable_init();\n    __AccessControl_init();\n    __ERC20Permit_init(name);\n    __UUPSUpgradeable_init();\n\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    renounceRole(MINTER_ROLE, msg.sender);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _longShort);\n    _setupRole(MINTER_ROLE, _longShort);\n    _setupRole(UPGRADER_ROLE, msg.sender);\n\n    longShort = _longShort;\n    staker = _staker;\n    marketIndex = _marketIndex;\n    isLong = _isLong;\n  }\n\n  /// @notice Authorizes an upgrade to a new address.\n  /// @dev Can only be called by the current admin.\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n  // TODO - look at some way of not duplicating implementation logic between this and SyntheticToken.sol\n\n  /// @notice Allows users to stake their synthetic tokens to earn Float.\n  /// @dev Core staking logic contained in Staker.sol\n  /// @param amount Amount to stake in wei.\n  function stake(uint256 amount) external override {\n    // NOTE: this is safe, this function will throw \"ERC20: transfer\n    //       amount exceeds balance\" if amount exceeds users balance.\n    super._transfer(msg.sender, address(staker), amount);\n\n    IStaker(staker).stakeFromUser(msg.sender, amount);\n  }\n\n  /*╔══════════════════════════════════════════════════════╗\n    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauser    ║\n    ╚══════════════════════════════════════════════════════╝*/\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(ERC20Upgradeable, ISyntheticToken)\n    returns (uint256)\n  {\n    return ERC20Upgradeable.totalSupply();\n  }\n\n  /** \n  @notice Mints a number of synthetic tokens for an address.\n  @dev Can only be called by addresses with a minter role. \n        This should correspond to the Long Short contract.\n  @param to The address for which to mint the tokens for.\n  @param amount Amount of synthetic tokens to mint in wei.\n  */\n  function mint(address to, uint256 amount) external override onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n  }\n\n  /// @notice Burns or destroys a number of held synthetic tokens for an address.\n  /// @dev Modified to only allow Long Short to burn tokens on redeem.\n  /// @param amount The amount of tokens to burn in wei.\n  function burn(uint256 amount) public override(ERC20BurnableUpgradeable, ISyntheticToken) {\n    require(msg.sender == longShort, \"Only LongShort contract\");\n    super._burn(_msgSender(), amount);\n  }\n\n  /** \n  @notice Overrides the default ERC20 transferFrom.\n  @dev To allow users to avoid approving LongShort when redeeming tokens,\n       longShort has a virtual infinite allowance.\n  @param sender User for which to transfer tokens.\n  @param recipient Recipient of the transferred tokens.\n  @param amount Amount of tokens to transfer in wei.\n  */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override(ERC20Upgradeable, ISyntheticToken) returns (bool) {\n    if (recipient == longShort && msg.sender == longShort) {\n      // If it to longShort and msg.sender is longShort don't perform additional transfer checks.\n      ERC20Upgradeable._transfer(sender, recipient, amount);\n      return true;\n    } else {\n      return ERC20Upgradeable.transferFrom(sender, recipient, amount);\n    }\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override(ERC20Upgradeable, ISyntheticToken)\n    returns (bool)\n  {\n    return ERC20Upgradeable.transfer(recipient, amount);\n  }\n\n  /** \n  @notice Overrides the OpenZeppelin _beforeTokenTransfer hook\n  @dev Ensures that this contract's accounting reflects all the senders's outstanding\n       tokens from next price actions before any token transfer occurs.\n       Removal of pausing functionality of ERC20PresetMinterPausable is intentional.\n  @param sender User for which tokens are to be transferred for.\n  */\n  function _beforeTokenTransfer(\n    address sender,\n    address to,\n    uint256 amount\n  ) internal override {\n    if (sender != longShort) {\n      ILongShort(longShort).executeOutstandingNextPriceSettlementsUser(sender, marketIndex);\n    }\n    super._beforeTokenTransfer(sender, to, amount);\n  }\n\n  /** \n  @notice Gets the synthetic token balance of the user in wei.\n  @dev To automatically account for next price actions which have been confirmed but not settled,\n        includes any outstanding tokens owed by longShort.\n  @param account The address for which to get the balance of.\n  */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return\n      ERC20Upgradeable.balanceOf(account) +\n      ILongShort(longShort).getUsersConfirmedButNotSettledSynthBalance(\n        account,\n        marketIndex,\n        isLong\n      );\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/StakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./StrategyToken.sol\";\n\n/** @title ILO Contract */\ncontract StakingStrategy is Initializable, UUPSUpgradeable, AccessControlUpgradeable {\n  bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n  address public longShort;\n  address public staker;\n  StrategyToken public strategyToken;\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SETUP        ║\n    ╚═════════════════════════════╝*/\n\n  function initialize(\n    string calldata name,\n    string calldata symbol,\n    address _longShort,\n    address _staker\n  ) external initializer {\n    __AccessControl_init();\n    __UUPSUpgradeable_init();\n\n    longShort = _longShort;\n    strategyToken = new StrategyToken(name, symbol);\n    staker = _staker;\n\n    _setupRole(UPGRADER_ROLE, msg.sender);\n    grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n  /*╔═════════════════════════════╗\n    ║           DEPOSIT           ║\n    ╚═════════════════════════════╝*/\n  function depositLongAndShortTokens(\n    uint32 marketIndex,\n    uint256 amountToken,\n    bool isLong\n  ) public {\n    ILongShort _longShort = ILongShort(longShort);\n    address longTokenAddress = _longShort.syntheticTokens(marketIndex, true);\n    address shortTokenAddress = _longShort.syntheticTokens(marketIndex, false);\n\n    //TODO\n    //can maybe add this method to longShort contract?\n    (uint256 longTokenPrice, uint256 shortTokenPrice) = _getLongAndShortTokenPrice(marketIndex);\n\n    (uint256 longShortRatio, uint256 beforeBalanceOfContract) = _getContractStakedBalanceAndRatio(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress,\n      longTokenPrice,\n      shortTokenPrice\n    );\n    (uint256 _amountStakedLong, uint256 _amountStakedShort) = _getTotalLongAndShortTokensStaked(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress\n    );\n    uint256 amountOfTokensToMatchRatio;\n\n    if (isLong) {\n      amountOfTokensToMatchRatio = amountToken / (longShortRatio);\n    } else {\n      amountOfTokensToMatchRatio = amountToken * longShortRatio;\n    }\n\n    //TODO\n    //two transfers - can optimise\n    ISyntheticToken(_longShort.syntheticTokens(marketIndex, isLong)).transferFrom(\n      msg.sender,\n      address(this),\n      amountToken\n    );\n    ISyntheticToken(_longShort.syntheticTokens(marketIndex, !isLong)).transferFrom(\n      msg.sender,\n      address(this),\n      amountOfTokensToMatchRatio\n    );\n\n    ISyntheticToken(_longShort.syntheticTokens(marketIndex, isLong)).stake(amountToken);\n    ISyntheticToken(_longShort.syntheticTokens(marketIndex, !isLong)).stake(\n      amountOfTokensToMatchRatio\n    );\n\n    (uint256 finalLongShortRatio, uint256 totalValueStaked) = _getContractStakedBalanceAndRatio(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress,\n      longTokenPrice,\n      shortTokenPrice\n    );\n\n    if (finalLongShortRatio != 1) {\n      _performShiftingStrategy(\n        marketIndex,\n        totalValueStaked,\n        longTokenAddress,\n        shortTokenAddress,\n        longTokenPrice,\n        shortTokenPrice\n      );\n    }\n\n    //TODO can seperate this into it's own method?\n    uint256 shares;\n\n    if (strategyToken.totalSupply() == 0) {\n      shares = totalValueStaked;\n    } else {\n      // Users deposited amount * cost per share\n      //cost per share =\n      shares =\n        (((totalValueStaked - beforeBalanceOfContract)) * beforeBalanceOfContract) /\n        strategyToken.totalSupply();\n    }\n\n    strategyToken.mint(msg.sender, shares);\n  }\n\n  /*╔═════════════════════════════╗\n    ║       HELPER FUNCTIONS      ║\n    ╚═════════════════════════════╝*/\n\n  //Retrieves the number of long and short tokens staked by this contract\n  function _getTotalLongAndShortTokensStaked(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress\n  ) internal view returns (uint256, uint256) {\n    IStaker _staker = IStaker(staker);\n    uint256 amountStakedLong = _staker.userAmountStaked(longTokenAddress, address(this));\n    uint256 amountStakedShort = _staker.userAmountStaked(shortTokenAddress, address(this));\n\n    return (amountStakedLong, amountStakedShort);\n  }\n\n  //TODO calculate the shares for the user\n  function _calculateUserShares() internal returns (uint256) {\n    // add the logic for share distribution here\n  }\n\n  //Gets the $ balance of the staked tokens\n  function _getContractStakedBalanceAndRatio(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    uint256 longTokenPrice,\n    uint256 shortTokenPrice\n  ) internal view returns (uint256, uint256) {\n    uint256 marketUpdateIndex = ILongShort(longShort).marketUpdateIndex(marketIndex);\n    (uint256 _amountStakedLong, uint256 _amountStakedShort) = _getTotalLongAndShortTokensStaked(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress\n    );\n    uint256 longSideValue = (_amountStakedLong * longTokenPrice) / 1e18;\n    uint256 shortSideValue = (_amountStakedShort * shortTokenPrice) / 1e18;\n\n    uint256 longShortRatio = longSideValue / shortSideValue;\n    uint256 contractBalance = (longSideValue + shortSideValue);\n\n    return (longShortRatio, contractBalance);\n  }\n\n  function _getLongAndShortTokenPrice(uint32 marketIndex)\n    internal\n    view\n    returns (uint256 longTokenPrice, uint256 shortTokenPrice)\n  {\n    uint256 marketUpdateIndex = ILongShort(longShort).marketUpdateIndex(marketIndex);\n    uint256 longTokenPrice = ILongShort(longShort).syntheticToken_priceSnapshot(\n      marketIndex,\n      true,\n      marketUpdateIndex\n    );\n    uint256 shortTokenPrice = ILongShort(longShort).syntheticToken_priceSnapshot(\n      marketIndex,\n      false,\n      marketUpdateIndex\n    );\n  }\n\n  /*╔═════════════════════════════╗\n    ║           STRATEGY          ║\n    ╚═════════════════════════════╝*/\n\n  //Perform the shifting strategy of this contract to ensure 50/50 balance of long short token values\n  function _performShiftingStrategy(\n    uint32 marketIndex,\n    uint256 totalValueStaked,\n    address longTokenAddress,\n    address shortTokenAddress,\n    uint256 longTokenPrice,\n    uint256 shortTokenPrice\n  ) internal {\n    (uint256 _amountStakedLong, uint256 _amountStakedShort) = _getTotalLongAndShortTokensStaked(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress\n    );\n\n    //50 - 50 split, can aim to make this resuable\n    uint256 desiredAmountOfLongTokens = ((totalValueStaked / 2) * 1e18) / longTokenPrice;\n    uint256 desiredAmountOfShortTokens = ((totalValueStaked / 2) * 1e18) / shortTokenPrice;\n\n    //check that no shifting occurs if the distribution of long and short tokens are already correct\n    if (_amountStakedLong > desiredAmountOfLongTokens) {\n      //Shift to short side\n      IStaker(staker).shiftTokens(_amountStakedLong - desiredAmountOfLongTokens, marketIndex, true);\n    } else if (_amountStakedShort > desiredAmountOfShortTokens) {\n      //shift to long side\n      IStaker(staker).shiftTokens(\n        _amountStakedShort - desiredAmountOfShortTokens,\n        marketIndex,\n        false\n      );\n    }\n  }\n\n  /// @notice Shifts tokens to either the long or the short position for the market to maintain 50/50 split in $ value\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  function performShiftingStrategy(uint32 marketIndex) external {\n    address longTokenAddress = ILongShort(longShort).syntheticTokens(marketIndex, true);\n    address shortTokenAddress = ILongShort(longShort).syntheticTokens(marketIndex, false);\n    (uint256 longTokenPrice, uint256 shortTokenPrice) = _getLongAndShortTokenPrice(marketIndex);\n\n    (uint256 longShortRatio, uint256 totalValueStaked) = _getContractStakedBalanceAndRatio(\n      marketIndex,\n      longTokenAddress,\n      shortTokenAddress,\n      longTokenPrice,\n      shortTokenPrice\n    );\n\n    if (longShortRatio != 1) {\n      _performShiftingStrategy(\n        marketIndex,\n        totalValueStaked,\n        longTokenAddress,\n        shortTokenAddress,\n        longTokenPrice,\n        shortTokenPrice\n      );\n    }\n  }\n}\n"
    },
    "contracts/StrategyToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract StrategyToken is ERC20Upgradeable, ERC20BurnableUpgradeable {\n  constructor(string memory name, string memory symbol) {\n    __ERC20_init(name, symbol);\n  }\n\n  function mint(address _recipient, uint256 _amount) external {\n    _mint(_recipient, _amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/FloatToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n @title FloatToken\n @notice The Float Token is the governance token for the Float Capital protocol\n */\ncontract FloatToken is\n  IFloatToken,\n  Initializable,\n  ERC20Upgradeable,\n  ERC20BurnableUpgradeable,\n  PausableUpgradeable,\n  AccessControlUpgradeable,\n  ERC20PermitUpgradeable,\n  ERC20VotesUpgradeable,\n  UUPSUpgradeable\n{\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n  /**\n   @notice Initialize the Float Token with relevant\n   @dev This function is called `initialize` to differentiate it from `initialize(string,string)` in the parent contract which should NOT be called to initialize this contract. \n   @param name The name of the Float governance token\n   @param symbol The ticker representing the token\n   @param stakerAddress The staker contract that controls minting of the token\n   */\n  function initialize(\n    string calldata name,\n    string calldata symbol,\n    address stakerAddress\n  ) external initializer {\n    __ERC20_init(name, symbol);\n    __ERC20Burnable_init();\n    __Pausable_init();\n    __AccessControl_init();\n    __ERC20Permit_init(name);\n    __UUPSUpgradeable_init();\n\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    renounceRole(MINTER_ROLE, msg.sender);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);\n    _setupRole(MINTER_ROLE, stakerAddress);\n    _setupRole(PAUSER_ROLE, msg.sender);\n\n    _setupRole(UPGRADER_ROLE, msg.sender);\n\n    // Token starts as paused\n    _pause();\n  }\n\n  /*╔═══════════════════════════════════════════════════════════════════╗\n    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauserUpgradeable      ║\n    ╚═══════════════════════════════════════════════════════════════════╝*/\n\n  /** \n  @notice Mints an amount of Float tokens for an address.\n  @dev Can only be called by addresses with a MINTER_ROLE. \n        This should correspond to the Staker contract.\n  @param to The address for which to mint the tokens for.\n  @param amount Amount of synthetic tokens to mint in wei.\n  */\n  function mint(address to, uint256 amount) external override(IFloatToken) onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n  }\n\n  /**\n   @notice modify token functionality so that a pausing this token doesn't affect minting\n   @dev Pause functionality in the open zeppelin ERC20PresetMinterPauserUpgradeable comes from the below function.\n    We override it to exclude anyone with the minter role (ie the Staker contract)\n   @param from address tokens are being sent from\n   @param to address tokens are being sent to\n   @param amount amount of tokens being sent\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    require(!paused() || hasRole(MINTER_ROLE, _msgSender()), \"Paused and not minter\");\n\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n    super._afterTokenTransfer(from, to, amount);\n  }\n\n  function _mint(address to, uint256 amount)\n    internal\n    override(ERC20Upgradeable, ERC20VotesUpgradeable)\n  {\n    super._mint(to, amount);\n  }\n\n  function _burn(address account, uint256 amount)\n    internal\n    override(ERC20Upgradeable, ERC20VotesUpgradeable)\n  {\n    super._burn(account, amount);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(ERC20Upgradeable, IFloatToken)\n    returns (uint256)\n  {\n    return ERC20Upgradeable.totalSupply();\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override(ERC20Upgradeable, IFloatToken)\n    returns (bool)\n  {\n    return ERC20Upgradeable.transfer(recipient, amount);\n  }\n\n  function burnFrom(address account, uint256 amount)\n    public\n    virtual\n    override(ERC20BurnableUpgradeable, IFloatToken)\n  {\n    ERC20BurnableUpgradeable.burnFrom(account, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/AlphaTestFLT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport \"./interfaces/IFloatToken.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n @title FloatToken\n @notice The Float Token is the governance token for the Float Capital protocol\n */\ncontract AlphaTestFLT is\n  IFloatToken,\n  Initializable,\n  ERC20Upgradeable,\n  ERC20BurnableUpgradeable,\n  PausableUpgradeable,\n  AccessControlUpgradeable,\n  ERC20PermitUpgradeable,\n  ERC20VotesUpgradeable,\n  UUPSUpgradeable\n{\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n  address public treasury;\n\n  /**\n   @notice Initialize the Float Token with relevant\n   @dev This function is called `initialize` to differentiate it from `initialize(string,string)` in the parent contract which should NOT be called to initialize this contract. \n   @param name The name of the Float governance token\n   @param symbol The ticker representing the token\n   @param stakerAddress The staker contract that controls minting of the token\n   */\n  function initialize(\n    string calldata name,\n    string calldata symbol,\n    address stakerAddress,\n    address treasuryAddress\n  ) external initializer {\n    __ERC20_init(name, symbol);\n    __ERC20Burnable_init();\n    __Pausable_init();\n    __AccessControl_init();\n    __ERC20Permit_init(name);\n    __UUPSUpgradeable_init();\n\n    treasury = treasuryAddress;\n\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    renounceRole(MINTER_ROLE, msg.sender);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);\n    _setupRole(MINTER_ROLE, stakerAddress);\n\n    _setupRole(PAUSER_ROLE, msg.sender);\n    _setupRole(UPGRADER_ROLE, msg.sender);\n\n    // Token starts as paused\n    _pause();\n  }\n\n  /*╔═══════════════════════════════════════════════════════════════════╗\n    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauserUpgradeable      ║\n    ╚═══════════════════════════════════════════════════════════════════╝*/\n\n  /** \n  @notice Mints an amount of Float tokens for an address.\n  @dev Can only be called by addresses with a MINTER_ROLE. \n        This should correspond to the Staker contract.\n  @param to The address for which to mint the tokens for.\n  @param amount Amount of synthetic tokens to mint in wei.\n  */\n  function mint(address to, uint256 amount) external override(IFloatToken) onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n  }\n\n  /**\n   @notice modify token functionality so that a pausing this token doesn't affect minting\n   @dev Pause functionality in the open zeppelin ERC20PresetMinterPauserUpgradeable comes from the below function.\n    We override it to exclude anyone with the minter role (ie the Staker contract)\n   @param from address tokens are being sent from\n   @param to address tokens are being sent to\n   @param amount amount of tokens being sent\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    require(!paused() || hasRole(MINTER_ROLE, _msgSender()), \"Paused and not minter\");\n\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\n\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n    super._afterTokenTransfer(from, to, amount);\n  }\n\n  function _mint(address to, uint256 amount)\n    internal\n    override(ERC20Upgradeable, ERC20VotesUpgradeable)\n  {\n    super._mint(to, amount);\n  }\n\n  function _burn(address account, uint256 amount)\n    internal\n    override(ERC20Upgradeable, ERC20VotesUpgradeable)\n  {\n    super._burn(account, amount);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(ERC20Upgradeable, IFloatToken)\n    returns (uint256)\n  {\n    return ERC20Upgradeable.totalSupply();\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override(ERC20Upgradeable, IFloatToken)\n    returns (bool)\n  {\n    return ERC20Upgradeable.transfer(recipient, amount);\n  }\n\n  function burnFrom(address account, uint256 amount)\n    public\n    virtual\n    override(ERC20BurnableUpgradeable, IFloatToken)\n  {\n    // If the burn comes from the treasury, let it happen automatically.\n    //   This is only for the alpha launch, no need to add these permissions to the main FLT deployment.\n    if (msg.sender == treasury) {\n      _burn(account, amount);\n    } else {\n      ERC20BurnableUpgradeable.burnFrom(account, amount);\n    }\n  }\n}\n"
    },
    "contracts/TreasuryAlpha.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/** This contract implementation is purely for the alpha, allowing the burning of FLT tokens\n  for a proportional share of the value held in the treasury. In contrast, the beta launch will be\n  rely on a more robust governance mechanism to vote on the buying and buring of FLT tokens using\n  treasury funds.*/\n\n/** @title Treasury Contract */\ncontract TreasuryAlpha is AccessControlledAndUpgradeable {\n  //Using Open Zeppelin safe transfer library for token transfers\n  using SafeERC20 for IERC20;\n\n  address public paymentToken;\n  address public floatToken;\n  address public longShort;\n  // An aproximation of what the FLT price should be according to the yield at the time.\n  uint256 public basePrice;\n  bool public redemptionsActivated;\n\n  event BasePriceUpdated(uint256 newBasePrice);\n\n  function initialize(\n    address _admin,\n    address _paymentToken,\n    address _floatToken,\n    address _longShort\n  ) external initializer {\n    _AccessControlledAndUpgradeable_init(_admin);\n    paymentToken = _paymentToken;\n    floatToken = _floatToken;\n    longShort = _longShort;\n  }\n\n  function onlyAdminModifierLogic() internal virtual {\n    _checkRole(ADMIN_ROLE, msg.sender);\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  modifier redemptionsActive() {\n    require(redemptionsActivated, \"redemptions haven't been activated\");\n    _;\n  }\n\n  function _getValueLockedInTreasury() internal view returns (uint256) {\n    return IERC20(paymentToken).balanceOf(address(this));\n  }\n\n  function _getFloatTokenSupply() internal view returns (uint256) {\n    return IFloatToken(floatToken).totalSupply();\n  }\n\n  function updateBasePrice(uint256 newBasePrice) public onlyAdmin {\n    // What should the minimum for this value be? 0.2 DAI per token seems reasonable if we are targetting 0.5 DAI as the normal price (and say Aave yield is poor or similar)\n    require(newBasePrice > 2e17, \"base price too low\");\n\n    basePrice = newBasePrice;\n    emit BasePriceUpdated(newBasePrice);\n  }\n\n  function activateRedemptions() public onlyAdmin {\n    redemptionsActivated = true;\n  }\n\n  function burnFloatForShareOfTreasury(uint256 amountOfFloatToBurn) external redemptionsActive {\n    uint256 priceAccordingToTreasuryAndSupply = (_getValueLockedInTreasury() * 1e18) /\n      _getFloatTokenSupply();\n    // In normal operation the `priceAccordingToTreasuryAndSupply` value will be an over-estimation favouring people who withdraw early. Thus typically the 'basePrice' will be a bit lower to prevent this in typical cases.\n    // We take the min of these two values so it is impossible for us to run with the money.\n    uint256 priceToUse = Math.min(priceAccordingToTreasuryAndSupply, basePrice);\n\n    uint256 amountToRecieve = (priceToUse * amountOfFloatToBurn) / 1e18;\n\n    IFloatToken(floatToken).burnFrom(msg.sender, amountOfFloatToBurn); // Can modify the core FLT token if wanted to remove the need for this step. // Currently requires user to approve treasury contract.\n    IERC20(paymentToken).safeTransfer(msg.sender, amountToRecieve);\n  }\n\n  function convertSynthsToPaymentTokenNextPriceLong(uint32 marketIndex, uint256 tokens_redeem)\n    external\n  {\n    ILongShort(longShort).redeemLongNextPrice(marketIndex, tokens_redeem);\n  }\n\n  function convertSynthsToPaymentTokenNextPriceShort(uint32 marketIndex, uint256 tokens_redeem)\n    external\n  {\n    ILongShort(longShort).redeemShortNextPrice(marketIndex, tokens_redeem);\n  }\n}\n"
    },
    "contracts/Treasury_v0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\n\n/** This contract implementation is purely for the alpha, allowing the burning of FLT tokens\n  for a proportional share of the value held in the treasury. In contrast, the beta launch will be\n  rely on a more robust governance mechanism to vote on the buying and buring of FLT tokens using\n  treasury funds.*/\n\n/** @title Treasury Contract */\ncontract Treasury_v0 is AccessControlledAndUpgradeable {\n  address public paymentToken;\n  address public floatToken;\n  address public longShort;\n\n  function initialize(\n    address _admin,\n    address _paymentToken,\n    address _floatToken,\n    address _longShort\n  ) external initializer {\n    _AccessControlledAndUpgradeable_init(_admin);\n    paymentToken = _paymentToken;\n    floatToken = _floatToken;\n    longShort = _longShort;\n  }\n\n  function convertSynthsToPaymentTokenNextPriceLong(uint32 marketIndex, uint256 tokens_redeem)\n    external\n  {\n    ILongShort(longShort).redeemLongNextPrice(marketIndex, tokens_redeem);\n  }\n\n  function convertSynthsToPaymentTokenNextPriceShort(uint32 marketIndex, uint256 tokens_redeem)\n    external\n  {\n    ILongShort(longShort).redeemShortNextPrice(marketIndex, tokens_redeem);\n  }\n}\n"
    },
    "contracts/SyntheticToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n/**\n@title SyntheticToken\n@notice An ERC20 token that tracks or inversely tracks the price of an\n        underlying asset with floating exposure.\n@dev Logic for price tracking contained in LongShort.sol. \n     The contract inherits from ERC20PresetMinterPauser.sol\n*/\ncontract SyntheticToken is ISyntheticToken, ERC20, ERC20Burnable, AccessControl, ERC20Permit {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /// @notice Address of the LongShort contract, a deployed LongShort.sol\n  address public immutable longShort;\n  /// @notice Address of the Staker contract, a deployed Staker.sol\n  address public immutable staker;\n  /// @notice Identifies which market in longShort the token is for.\n  uint32 public immutable marketIndex;\n  /// @notice Whether the token is a long token or short token for its market.\n  bool public immutable isLong;\n\n  /// @notice Creates an instance of the contract.\n  /// @dev Should only be called by TokenFactory.sol for our system.\n  /// @param name The name of the token.\n  /// @param symbol The symbol for the token.\n  /// @param _longShort Address of the core LongShort contract.\n  /// @param _staker Address of the staker contract.\n  /// @param _marketIndex Which market the token is for.\n  /// @param _isLong Whether the token is long or short for its market.\n  constructor(\n    string memory name,\n    string memory symbol,\n    address _longShort,\n    address _staker,\n    uint32 _marketIndex,\n    bool _isLong\n  ) ERC20(name, symbol) ERC20Permit(name) {\n    longShort = _longShort;\n    staker = _staker;\n    marketIndex = _marketIndex;\n    isLong = _isLong;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _longShort);\n    _setupRole(MINTER_ROLE, _longShort);\n  }\n\n  /// @notice Allows users to stake their synthetic tokens to earn Float.\n  /// @dev Core staking logic contained in Staker.sol\n  /// @param amount Amount to stake in wei.\n  function stake(uint256 amount) external override {\n    // NOTE: this is safe, this function will throw \"ERC20: transfer\n    //       amount exceeds balance\" if amount exceeds users balance.\n    super._transfer(msg.sender, address(staker), amount);\n\n    IStaker(staker).stakeFromUser(msg.sender, amount);\n  }\n\n  /*╔══════════════════════════════════════════════════════╗\n    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauser    ║\n    ╚══════════════════════════════════════════════════════╝*/\n\n  function totalSupply() public view virtual override(ERC20, ISyntheticToken) returns (uint256) {\n    return ERC20.totalSupply();\n  }\n\n  /** \n  @notice Mints a number of synthetic tokens for an address.\n  @dev Can only be called by addresses with a minter role. \n        This should correspond to the Long Short contract.\n  @param to The address for which to mint the tokens for.\n  @param amount Amount of synthetic tokens to mint in wei.\n  */\n  function mint(address to, uint256 amount) external override onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n  }\n\n  /// @notice Burns or destroys a number of held synthetic tokens for an address.\n  /// @dev Modified to only allow Long Short to burn tokens on redeem.\n  /// @param amount The amount of tokens to burn in wei.\n  function burn(uint256 amount) public override(ERC20Burnable, ISyntheticToken) {\n    require(msg.sender == longShort, \"Only LongShort contract\");\n    super._burn(_msgSender(), amount);\n  }\n\n  /** \n  @notice Overrides the default ERC20 transferFrom.\n  @dev To allow users to avoid approving LongShort when redeeming tokens,\n       longShort has a virtual infinite allowance.\n  @param sender User for which to transfer tokens.\n  @param recipient Recipient of the transferred tokens.\n  @param amount Amount of tokens to transfer in wei.\n  */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override(ERC20, ISyntheticToken) returns (bool) {\n    if (recipient == longShort && msg.sender == longShort) {\n      // If it to longShort and msg.sender is longShort don't perform additional transfer checks.\n      ERC20._transfer(sender, recipient, amount);\n      return true;\n    } else {\n      return ERC20.transferFrom(sender, recipient, amount);\n    }\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override(ERC20, ISyntheticToken)\n    returns (bool)\n  {\n    return ERC20.transfer(recipient, amount);\n  }\n\n  /** \n  @notice Overrides the OpenZeppelin _beforeTokenTransfer hook\n  @dev Ensures that this contract's accounting reflects all the senders's outstanding\n       tokens from next price actions before any token transfer occurs.\n       Removal of pausing functionality of ERC20PresetMinterPausable is intentional.\n  @param sender User for which tokens are to be transferred for.\n  */\n  function _beforeTokenTransfer(\n    address sender,\n    address to,\n    uint256 amount\n  ) internal override {\n    if (sender != longShort) {\n      ILongShort(longShort).executeOutstandingNextPriceSettlementsUser(sender, marketIndex);\n    }\n    super._beforeTokenTransfer(sender, to, amount);\n  }\n\n  /** \n  @notice Gets the synthetic token balance of the user in wei.\n  @dev To automatically account for next price actions which have been confirmed but not settled,\n        includes any outstanding tokens owed by longShort.\n  @param account The address for which to get the balance of.\n  */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return\n      ERC20.balanceOf(account) +\n      ILongShort(longShort).getUsersConfirmedButNotSettledSynthBalance(\n        account,\n        marketIndex,\n        isLong\n      );\n  }\n}\n"
    },
    "contracts/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./SyntheticToken.sol\";\nimport \"./interfaces/ITokenFactory.sol\";\n\n/// @title TokenFactory\n/// @notice contract is used to reliably mint the synthetic tokens used by the float protocol.\ncontract TokenFactory is ITokenFactory {\n  /*╔═══════════════════════════╗\n    ║           STATE           ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice address of long short contract\n  address public immutable longShort;\n\n  /*╔═══════════════════════════╗\n    ║         MODIFIERS         ║\n    ╚═══════════════════════════╝*/\n\n  /// @dev only allow longShort contract to call this function\n  modifier onlyLongShort() {\n    require(msg.sender == address(longShort));\n    _;\n  }\n\n  /*╔════════════════════════════╗\n    ║           SET-UP           ║\n    ╚════════════════════════════╝*/\n\n  /// @notice sets the address of the longShort contract on initialization\n  /// @param _longShort address of the longShort contract\n  constructor(address _longShort) {\n    longShort = _longShort;\n  }\n\n  /*╔════════════════════════════╗\n    ║       TOKEN CREATION       ║\n    ╚════════════════════════════╝*/\n\n  /// @notice creates and sets up a new synthetic token\n  /// @param syntheticName name of the synthetic token\n  /// @param syntheticSymbol ticker symbol of the synthetic token\n  /// @param staker address of the staker contract\n  /// @param marketIndex market index this synthetic token belongs to\n  /// @param isLong boolean denoting if the synthetic token is long or short\n  /// @return syntheticToken - address of the created synthetic token\n  function createSyntheticToken(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address staker,\n    uint32 marketIndex,\n    bool isLong\n  ) external override onlyLongShort returns (address syntheticToken) {\n    syntheticToken = address(\n      new SyntheticToken(syntheticName, syntheticSymbol, longShort, staker, marketIndex, isLong)\n    );\n  }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract ERC20Mock is ERC20PresetMinterPauser {\n  constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n\n  event TransferCalled(address sender, address recipient, uint256 amount);\n\n  bool shouldMockTransfer = true;\n\n  function setShouldMockTransfer(bool _value) public {\n    shouldMockTransfer = _value;\n  }\n\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\n    emit TransferCalled(_msgSender(), recipient, amount);\n    if (shouldMockTransfer) {\n      return true;\n    } else {\n      return super.transfer(recipient, amount);\n    }\n  }\n}\n"
    },
    "contracts/mocks/AaveIncentivesControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\nimport \"../interfaces/aave/IAaveIncentivesController.sol\";\n\ncontract AaveIncentivesControllerMock is IAaveIncentivesController {\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external override returns (uint256 amountToClaim) {}\n\n  function getUserUnclaimedRewards(address user)\n    external\n    view\n    override\n    returns (uint256 usersUnclaimedRewards)\n  {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/deployment/UUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n// Kept for backwards compatibility with older versions of Hardhat and Truffle plugins.\ncontract UUPSProxy is ERC1967Proxy {\n  constructor(\n    address _logic,\n    address, // This is completely unused by the uups proxy, required to remain compatible with hardhat deploy: https://github.com/wighawag/hardhat-deploy/issues/146\n    bytes memory _data\n  ) payable ERC1967Proxy(_logic, _data) {}\n}\n"
    },
    "contracts/mocks/OracleManagerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"../interfaces/IOracleManager.sol\";\n\n/*\n * Mock implementation of an OracleManager with fixed, changeable prices.\n */\ncontract OracleManagerMock is IOracleManager {\n  // Admin contract.\n  address public admin;\n\n  // Global state.\n  int256 currentPrice; // e18\n\n  ////////////////////////////////////\n  /////////// MODIFIERS //////////////\n  ////////////////////////////////////\n\n  modifier adminOnly() {\n    require(msg.sender == admin, \"Not admin\");\n    _;\n  }\n\n  ////////////////////////////////////\n  ///// CONTRACT SET-UP //////////////\n  ////////////////////////////////////\n\n  constructor(address _admin) {\n    admin = _admin;\n\n    // Default to a price of 1.\n    currentPrice = 1e18;\n  }\n\n  ////////////////////////////////////\n  ///// IMPLEMENTATION ///////////////\n  ////////////////////////////////////\n\n  function setPrice(int256 newPrice) public adminOnly {\n    currentPrice = newPrice;\n  }\n\n  function updatePrice() external override returns (int256) {\n    return currentPrice;\n  }\n\n  function getLatestPrice() external view override returns (int256) {\n    return currentPrice;\n  }\n}\n"
    },
    "contracts/mocks/LendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"../interfaces/aave/ILendingPoolAddressesProvider.sol\";\n\ncontract LendingPoolAddressesProviderMock is ILendingPoolAddressesProvider {\n  address public lendingPool;\n\n  function setLendingPool(address _lendingPool) external {\n    lendingPool = _lendingPool;\n  }\n\n  function getLendingPool() external view override returns (address) {\n    return lendingPool;\n  }\n}\n"
    },
    "contracts/FloatCapital_v0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"./abstract/AccessControlledAndUpgradeable.sol\";\n\n/** @title Float Capital Contract */\ncontract FloatCapital_v0 is AccessControlledAndUpgradeable {\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SETUP        ║\n    ╚═════════════════════════════╝*/\n\n  function initialize(address _admin) external initializer {\n    _AccessControlledAndUpgradeable_init(_admin);\n  }\n\n  /** A percentage of float token to accrue here for project\n     development */\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}